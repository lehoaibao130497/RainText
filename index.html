<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rain Effect - VƒÉn b·∫£n & H√¨nh ·∫£nh r∆°i</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
            user-select: none;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ffff;
        }

        #loading.hidden {
            display: none;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #00ffff;
            min-width: 280px;
            z-index: 10;
            transition: transform 0.3s ease, opacity 0.3s ease;
            /* ·∫®n m·∫∑c ƒë·ªãnh */
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }

        #controls.visible {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto;
        }



        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ff6b6b;
            max-width: 300px;
            font-size: 14px;
            z-index: 10;
            transition: transform 0.3s ease, opacity 0.3s ease;
            /* ·∫®n m·∫∑c ƒë·ªãnh */
            transform: translateX(100%);
            opacity: 0;
            pointer-events: none;
        }

        #info.visible {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto;
        }



        #webgl-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            display: none;
            z-index: 200;
        }

        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ffff;
            font-weight: bold;
        }

        select, button, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #00ffff;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 14px;
        }

        button {
            background: linear-gradient(45deg, #00ffff, #ff6b6b);
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .status {
            color: #ff6b6b;
            font-weight: bold;
        }

        .value-display {
            color: #00ffff;
            font-weight: bold;
        }

        /* Main settings button */
        #main-settings:hover {
            background: rgba(0, 255, 255, 1) !important;
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.5);
        }

        /* Toggle buttons trong controls */
        #toggle-info:hover {
            /*background: rgba(255, 107, 107, 1) !important;*/
            transform: scale(1.05);
        }

        #toggle-controls:hover {
            /*background: rgba(255, 193, 7, 1) !important;*/
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            #controls {
                top: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                padding: 15px;
            }
            
            #info {
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            #controls {
                font-size: 12px;
            }
            
            select, button, input[type="range"] {
                font-size: 12px;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <div id="loading">
            <div class="spinner"></div>
            <h3>ƒêang t·∫£i c·∫£nh 3D...</h3>
            <p>Chu·∫©n b·ªã c√°c ƒë·ªëi t∆∞·ª£ng r∆°i</p>
        </div>

        <!-- Main Settings Button -->
        <button id="main-settings" style="position: absolute; top: 20px; left: 20px; background: transparent; color: black; border: none; padding: 12px 18px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; z-index: 11; box-shadow: none;" title="M·ªü c√†i ƒë·∫∑t">‚öôÔ∏è Settings</button>



        <div id="controls">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #00ffff; margin: 0;">üéÆ ƒêi·ªÅu khi·ªÉn</h3>
                <div>
                    <button id="toggle-info" title="·∫®n/Hi·ªán h∆∞·ªõng d·∫´n" style="background: transparent; color: white; border: none; padding: 5px; border-radius: 5px; cursor: pointer; margin-right: 8px; font-size: 14px;">‚ùì</button>
                    <button id="toggle-controls" title="·∫®n ƒëi·ªÅu khi·ªÉn" style="background: transparent; color: black; border: none; padding: 5px; border-radius: 5px; cursor: pointer; font-size: 14px;">üîΩ</button>
                </div>
            </div>
            
            <div class="control-group">
                <label for="mode-select">Ch·∫ø ƒë·ªô hi·ªÉn th·ªã:</label>
                <select id="mode-select">
                    <option value="text">üìù VƒÉn b·∫£n</option>
                    <option value="images">üñºÔ∏è H√¨nh ·∫£nh</option>
                    <option value="mixed">üé≠ K·∫øt h·ª£p</option>
                </select>
            </div>

            <div class="control-group">
                <label for="object-count">S·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng: <span id="count-value" class="value-display">120</span></label>
                <input type="range" id="object-count" min="20" max="500" value="120">
            </div>

            <div class="control-group">
                <label for="fall-speed">T·ªëc ƒë·ªô r∆°i: <span id="speed-value" class="value-display">5</span></label>
                <input type="range" id="fall-speed" min="1" max="10" step="1" value="5">
            </div>

            <div class="control-group">
                <button id="add-objects">‚ûï Th√™m ƒë·ªëi t∆∞·ª£ng</button>
            </div>

            <div class="control-group">
                <button id="clear-objects">üóëÔ∏è X√≥a t·∫•t c·∫£</button>
            </div>

            <div class="control-group">
                <button id="reload-data">üîÑ T·∫£i l·∫°i d·ªØ li·ªáu</button>
            </div>

            <div class="control-group">
                <label for="music-type">Lo·∫°i nh·∫°c:</label>
                <select id="music-type">
                    <option value="ambient">üéπ Ambient (Web Audio)</option>
                    <option value="mp3">üéµ MP3 Files</option>
                </select>
            </div>

            <div class="control-group">
                <button id="toggle-music">üéµ B·∫≠t/T·∫Øt nh·∫°c</button>
            </div>

            <div class="control-group">
                <button id="next-track" style="display: none;">‚è≠Ô∏è B√†i ti·∫øp</button>
            </div>

            <div class="control-group">
                <label for="music-volume">√Çm l∆∞·ª£ng nh·∫°c:</label>
                <input type="range" id="music-volume" min="0" max="1" step="0.1" value="0.1">
                <span id="volume-value">10%</span>
            </div>

            <div class="control-group" id="current-track-info" style="display: none;">
                <p><strong>ƒêang ph√°t:</strong></p>
                <p class="status" id="current-track">Kh√¥ng c√≥</p>
            </div>

            <div class="control-group">
                <p><strong>ƒê·ªëi t∆∞·ª£ng ƒë∆∞·ª£c ch·ªçn:</strong></p>
                <p class="status" id="selected-object">Kh√¥ng c√≥</p>
            </div>

            <div class="control-group">
                <p><strong>Tr·∫°ng th√°i:</strong></p>
                <p class="status" id="data-status">ƒêang t·∫£i...</p>
            </div>
        </div>

        <div id="info">
            <h4>üéØ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng</h4>
            <ul style="margin: 10px 0; padding-left: 20px; font-size: 13px;">
                <li>üñ±Ô∏è <strong>K√©o chu·ªôt:</strong> Xoay camera</li>
                <li>üëÜ <strong>Click ph·∫ßn t·ª≠:</strong> D·ª´ng r∆°i</li>
                <li>üîç <strong>Scroll wheel:</strong> Zoom ph·∫ßn t·ª≠ ƒë∆∞·ª£c ch·ªçn</li>
                <li>üñ±Ô∏è <strong>Click ra ngo√†i:</strong> Tr·ªü v·ªÅ b√¨nh th∆∞·ªùng</li>
                <li>üì± <strong>Touch:</strong> Tap ch·ªçn, pinch zoom</li>
            </ul>

            <h5 style="color: #00ffff; margin: 10px 0 5px 0;">‚å®Ô∏è Ph√≠m t·∫Øt:</h5>
            <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
                <li><strong>S:</strong> M·ªü settings (khi UI ·∫©n)</li>
                <li><strong>C:</strong> ·∫®n/hi·ªán ƒëi·ªÅu khi·ªÉn</li>
                <li><strong>H ho·∫∑c ?:</strong> ·∫®n/hi·ªán h∆∞·ªõng d·∫´n</li>
                <li><strong>Space:</strong> B·∫≠t/t·∫Øt nh·∫°c</li>
                <li><strong>Ctrl+R:</strong> T·∫£i l·∫°i d·ªØ li·ªáu</li>
                <li><strong>Esc:</strong> B·ªè ch·ªçn ƒë·ªëi t∆∞·ª£ng</li>
            </ul>

            <p style="margin-top: 10px;"><strong>FPS:</strong> <span id="fps-counter" class="value-display">60</span></p>
        </div>

        <div id="webgl-error">
            <h3>‚ùå Kh√¥ng h·ªó tr·ª£ WebGL</h3>
            <p>Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ WebGL. Vui l√≤ng s·ª≠ d·ª•ng Chrome, Firefox, Safari ho·∫∑c Edge phi√™n b·∫£n m·ªõi.</p>
        </div>
    </div>

    <!-- Three.js CDN v·ªõi loading management -->
    <script>
        // Global loading state
        window.librariesLoaded = {
            threejs: false,
            orbitcontrols: false
        };

        // Load Three.js
        function loadThreeJS() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js';

                script.onload = function() {
                    console.log('‚úÖ Three.js loaded successfully');
                    window.librariesLoaded.threejs = true;
                    resolve();
                };

                script.onerror = function() {
                    console.warn('‚ö†Ô∏è Primary CDN failed, trying backup...');
                    loadThreeJSBackup().then(resolve).catch(reject);
                };

                document.head.appendChild(script);
            });
        }

        // Backup Three.js loader
        function loadThreeJSBackup() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/three@0.155.0/build/three.min.js';

                script.onload = function() {
                    console.log('‚úÖ Three.js loaded from backup CDN');
                    window.librariesLoaded.threejs = true;
                    resolve();
                };

                script.onerror = function() {
                    console.error('‚ùå All Three.js CDNs failed');
                    document.getElementById('loading').innerHTML = `
                        <h3>‚ùå L·ªói t·∫£i th∆∞ vi·ªán</h3>
                        <p>Kh√¥ng th·ªÉ t·∫£i Three.js. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet v√† th·ª≠ l·∫°i.</p>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 10px; background: #00ffff; border: none; border-radius: 5px; cursor: pointer;">üîÑ Th·ª≠ l·∫°i</button>
                    `;
                    reject(new Error('Failed to load Three.js'));
                };

                document.head.appendChild(script);
            });
        }

        // Load OrbitControls
        function loadOrbitControls() {
            return new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'https://threejs.org/examples/js/controls/OrbitControls.js';

                script.onload = function() {
                    console.log('‚úÖ OrbitControls loaded successfully');
                    window.librariesLoaded.orbitcontrols = true;
                    resolve();
                };

                script.onerror = function() {
                    console.warn('‚ö†Ô∏è OrbitControls failed to load, will use basic controls');
                    window.librariesLoaded.orbitcontrols = false;
                    resolve(); // Don't reject, just continue without OrbitControls
                };

                document.head.appendChild(script);
            });
        }

        // Load all libraries sequentially
        async function loadAllLibraries() {
            try {
                await loadThreeJS();
                await loadOrbitControls();
                console.log('üéâ All libraries loaded successfully');
                return true;
            } catch (error) {
                console.error('‚ùå Failed to load libraries:', error);
                return false;
            }
        }

        // Start loading immediately
        loadAllLibraries();
    </script>

    <!-- Audio Systems -->
    <script src="audio/ambient-music.js"></script>
    <script src="audio/mp3-player.js"></script>

    <script>
        /**
         * 3D Rain Effect Demo - VƒÉn b·∫£n v√† H√¨nh ·∫£nh r∆°i t∆∞∆°ng t√°c
         * T√°c gi·∫£: AI Assistant
         * Phi√™n b·∫£n: 1.0
         */

        // C·∫•u h√¨nh ch√≠nh
        const CONFIG = {
            // File paths
            TEXT_CSV: 'text/words.csv',
            IMAGES_CSV: 'images/images.csv',
            IMAGES_PATH: 'images/',
            AUDIO_CSV: 'audio/playlist.csv',
            AUDIO_PATH: 'audio/',

            // Danh s√°ch vƒÉn b·∫£n (s·∫Ω ƒë∆∞·ª£c load t·ª´ CSV)
            WORDS: [],

            // Danh s√°ch h√¨nh ·∫£nh (s·∫Ω ƒë∆∞·ª£c load t·ª´ CSV)
            IMAGES: [],
            
            // Tham s·ªë r∆°i
            FALL_SPEED: { min: 0.015, max: 0.025 },
            RESPAWN_Y: 60,
            DESPAWN_Y: -60,
            SPREAD_AREA: 100,
            
            // Tham s·ªë ƒë·ªëi t∆∞·ª£ng
            OBJECT_SIZE: { min: 2, max: 40 },
            FONT_SIZE: 64,
            
            // Tham s·ªë camera
            CAMERA_DISTANCE: 30,
            ZOOM_RANGE: { min: 5, max: 100 },
            
            // Tham s·ªë t∆∞∆°ng t√°c
            SCALE_RANGE: { min: 0.5, max: 10 },
            HOVER_SCALE: 1.2,
            SELECT_SCALE: 1.5
        };

        // Bi·∫øn to√†n c·ª•c
        let scene, camera, renderer, controls;
        let objects = [];
        let selectedObject = null;
        let raycaster, mouse;
        let isInteracting = false;
        let currentMode = 'text';
        let fallSpeedMultiplier = 5;

        // Music system
        let musicGenerator = null;
        let mp3Player = null;
        let isMusicPlaying = false;
        let currentMusicType = 'ambient'; // 'ambient' or 'mp3'

        // Data loading
        let dataLoaded = false;

        // UI state - m·∫∑c ƒë·ªãnh ·∫©n t·∫•t c·∫£
        let controlsVisible = false;
        let infoVisible = false;

        // FPS tracking
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;

        // Kh·ªüi t·∫°o ·ª©ng d·ª•ng khi DOM v√† libraries ƒë√£ s·∫µn s√†ng
        async function startApp() {
            console.log('üöÄ Starting application...');

            // ƒê·ª£i DOM s·∫µn s√†ng
            if (document.readyState === 'loading') {
                await new Promise(resolve => {
                    document.addEventListener('DOMContentLoaded', resolve);
                });
            }

            // ƒê·ª£i libraries load xong
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds max

            while (attempts < maxAttempts) {
                if (window.librariesLoaded && window.librariesLoaded.threejs) {
                    console.log('üìö Libraries ready, initializing...');
                    init();
                    return;
                }

                console.log(`‚è≥ Waiting for libraries... (${attempts + 1}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }

            // Timeout - show error
            console.error('‚ùå Timeout waiting for libraries');
            document.getElementById('loading').innerHTML = `
                <h3>‚ùå Timeout</h3>
                <p>Th∆∞ vi·ªán t·∫£i qu√° l√¢u. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet.</p>
                <button onclick="location.reload()" style="margin-top: 10px; padding: 10px; background: #00ffff; border: none; border-radius: 5px; cursor: pointer;">üîÑ Th·ª≠ l·∫°i</button>
            `;
        }

        // B·∫Øt ƒë·∫ßu ·ª©ng d·ª•ng
        startApp();

        /**
         * Ki·ªÉm tra h·ªó tr·ª£ WebGL
         */
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                return !!gl;
            } catch (e) {
                return false;
            }
        }

        /**
         * Kh·ªüi t·∫°o c·∫£nh 3D v√† b·∫Øt ƒë·∫ßu animation
         */
        function init() {
            console.log('üé¨ Initializing 3D scene...');

            // Ki·ªÉm tra WebGL tr∆∞·ªõc
            if (!checkWebGLSupport()) {
                console.error('‚ùå WebGL kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£');
                showWebGLError();
                return;
            }

            // Ki·ªÉm tra Three.js ƒë√£ load ch∆∞a
            if (typeof THREE === 'undefined') {
                console.error('‚ùå Three.js ch∆∞a ƒë∆∞·ª£c t·∫£i');
                document.getElementById('loading').innerHTML = `
                    <h3>‚ùå L·ªói kh·ªüi t·∫°o</h3>
                    <p>Three.js ch∆∞a ƒë∆∞·ª£c t·∫£i. ƒêang th·ª≠ l·∫°i...</p>
                `;
                setTimeout(init, 500); // Th·ª≠ l·∫°i sau 500ms
                return;
            }

            // Log Three.js version
            console.log(`üì¶ Three.js version: ${THREE.REVISION}`);

            try {
                setupScene();
                setupLighting();
                setupBackground();
                setupControls();
                setupEventListeners();
                loadDataFiles();
                initMusicSystem();
                createInitialObjects();
                hideLoading();
                animate();
                console.log('‚úÖ Kh·ªüi t·∫°o th√†nh c√¥ng!');
            } catch (error) {
                console.error('‚ùå L·ªói kh·ªüi t·∫°o c·∫£nh 3D:', error);
                console.error('Error details:', error);
                showWebGLError();
            }
        }

        /**
         * Thi·∫øt l·∫≠p scene, camera v√† renderer
         */
        function setupScene() {
            // T·∫°o scene
            scene = new THREE.Scene();

            // T·∫°o camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            camera.position.set(0, 0, CONFIG.CAMERA_DISTANCE);

            // T·∫°o renderer v·ªõi error handling
            const canvas = document.getElementById('canvas');
            try {
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
            } catch (error) {
                console.error('‚ùå Kh√¥ng th·ªÉ t·∫°o WebGL renderer:', error);
                throw new Error('WebGL kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a');
            }

            // Ki·ªÉm tra WebGL context
            const gl = renderer.getContext();
            if (!gl) {
                throw new Error('Kh√¥ng th·ªÉ l·∫•y WebGL context');
            }

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // T·∫Øt shadow n·∫øu kh√¥ng h·ªó tr·ª£ ƒë·ªÉ tƒÉng t∆∞∆°ng th√≠ch
            try {
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            } catch (error) {
                console.warn('‚ö†Ô∏è Shadow mapping kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£, t·∫Øt shadows');
                renderer.shadowMap.enabled = false;
            }

            // T·∫°o raycaster cho t∆∞∆°ng t√°c
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        /**
         * Thi·∫øt l·∫≠p √°nh s√°ng cho scene
         */
        function setupLighting() {
            // √Ånh s√°ng m√¥i tr∆∞·ªùng
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // √Ånh s√°ng ƒë·ªãnh h∆∞·ªõng
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // √Ånh s√°ng ƒëi·ªÉm ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng
            const pointLight = new THREE.PointLight(0x00ffff, 0.5, 100);
            pointLight.position.set(0, 20, 10);
            scene.add(pointLight);
        }

        /**
         * T·∫°o background kh√¥ng gian v·ªõi c√°c v√¨ sao l·∫•p l√°nh
         */
        function setupBackground() {
            // T·∫°o starfield v·ªõi nhi·ªÅu k√≠ch th∆∞·ªõc kh√°c nhau
            const starsGeometry = new THREE.BufferGeometry();
            const starsVertices = [];
            const starsSizes = [];
            const starsColors = [];

            for (let i = 0; i < 20000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);

                // K√≠ch th∆∞·ªõc ng·∫´u nhi√™n t·ª´ 2-8
                starsSizes.push(2 + Math.random() * 6);

                // M√†u s·∫Øc ng·∫´u nhi√™n (tr·∫Øng, xanh nh·∫°t, v√†ng nh·∫°t)
                const colorVariant = Math.random();
                if (colorVariant < 0.7) {
                    starsColors.push(1, 1, 1); // Tr·∫Øng
                } else if (colorVariant < 0.85) {
                    starsColors.push(0.8, 0.9, 1); // Xanh nh·∫°t
                } else {
                    starsColors.push(1, 1, 0.8); // V√†ng nh·∫°t
                }
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            starsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starsSizes, 1));
            starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starsColors, 3));

            // Shader material cho hi·ªáu ·ª©ng l·∫•p l√°nh
            const starsMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vSize;
                    uniform float time;

                    void main() {
                        vColor = color;
                        vSize = size;

                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                        // Hi·ªáu ·ª©ng l·∫•p l√°nh
                        float twinkle = sin(time * 2.0 + position.x * 0.01 + position.y * 0.01) * 0.5 + 0.5;
                        gl_PointSize = size * (0.5 + twinkle * 0.5);

                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    uniform float time;

                    void main() {
                        float distance = length(gl_PointCoord - vec2(0.5));
                        if (distance > 0.5) discard;

                        // Hi·ªáu ·ª©ng glow
                        float alpha = 1.0 - distance * 2.0;
                        alpha = pow(alpha, 2.0);

                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);

            // L∆∞u reference ƒë·ªÉ animate
            scene.userData.starField = starField;
            scene.userData.starsMaterial = starsMaterial;

            // T·∫°o nebula background
            const nebulaGeometry = new THREE.SphereGeometry(1000, 32, 32);
            const nebulaMaterial = new THREE.MeshBasicMaterial({
                color: 0x000033,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);
        }

        /**
         * Thi·∫øt l·∫≠p ƒëi·ªÅu khi·ªÉn camera
         */
        function setupControls() {
            // Ki·ªÉm tra OrbitControls c√≥ s·∫µn kh√¥ng
            if (typeof THREE.OrbitControls === 'undefined') {
                console.warn('‚ö†Ô∏è OrbitControls kh√¥ng c√≥ s·∫µn, s·ª≠ d·ª•ng ƒëi·ªÅu khi·ªÉn c∆° b·∫£n');
                setupBasicControls();
                return;
            }

            try {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = CONFIG.ZOOM_RANGE.min;
                controls.maxDistance = CONFIG.ZOOM_RANGE.max;
                controls.enablePan = false;
                controls.autoRotate = false;
                controls.autoRotateSpeed = 0.5;
            } catch (error) {
                console.warn('‚ö†Ô∏è L·ªói kh·ªüi t·∫°o OrbitControls:', error);
                setupBasicControls();
            }
        }

        /**
         * Thi·∫øt l·∫≠p ƒëi·ªÅu khi·ªÉn camera c∆° b·∫£n (fallback)
         */
        function setupBasicControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let cameraDistance = CONFIG.CAMERA_DISTANCE;

            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                // Xoay camera quanh scene
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                cameraDistance += event.deltaY * 0.01;
                cameraDistance = Math.max(CONFIG.ZOOM_RANGE.min, Math.min(CONFIG.ZOOM_RANGE.max, cameraDistance));

                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(cameraDistance));
            });

            // T·∫°o object gi·∫£ ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi code kh√°c
            controls = {
                update: () => {},
                enableDamping: false
            };
        }

        /**
         * Thi·∫øt l·∫≠p c√°c event listener
         */
        function setupEventListeners() {
            // Mouse events
            renderer.domElement.addEventListener('click', onMouseClick, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('wheel', onMouseWheel, false);

            // Touch events
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            // Window resize
            window.addEventListener('resize', onWindowResize, false);

            // UI controls
            document.getElementById('mode-select').addEventListener('change', onModeChange);
            document.getElementById('object-count').addEventListener('input', onObjectCountChange);
            document.getElementById('fall-speed').addEventListener('input', onFallSpeedChange);
            document.getElementById('add-objects').addEventListener('click', addObjects);
            document.getElementById('clear-objects').addEventListener('click', clearAllObjects);
            document.getElementById('reload-data').addEventListener('click', reloadData);
            document.getElementById('toggle-music').addEventListener('click', toggleMusic);
            document.getElementById('next-track').addEventListener('click', nextTrack);
            document.getElementById('music-type').addEventListener('change', onMusicTypeChange);
            document.getElementById('music-volume').addEventListener('input', onVolumeChange);

            // Main settings button
            document.getElementById('main-settings').addEventListener('click', showSettings);

            // Toggle buttons
            document.getElementById('toggle-controls').addEventListener('click', toggleControls);
            document.getElementById('toggle-info').addEventListener('click', toggleInfo);

            // Keyboard shortcuts
            document.addEventListener('keydown', onKeyDown);
        }

        /**
         * Load data t·ª´ CSV files
         */
        async function loadDataFiles() {
            updateDataStatus('ƒêang t·∫£i d·ªØ li·ªáu...');

            try {
                // Load text data
                const textData = await loadCSV(CONFIG.TEXT_CSV);
                CONFIG.WORDS = textData.map(row => ({
                    text: row.text,
                    category: row.category || 'default',
                    hue: parseInt(row.color_hue) || Math.random() * 360
                }));

                // Load image data
                const imageData = await loadCSV(CONFIG.IMAGES_CSV);
                CONFIG.IMAGES = imageData.map(row => ({
                    filename: row.filename,
                    name: row.name,
                    category: row.category || 'default',
                    hue: parseInt(row.color_hue) || Math.random() * 360,
                    path: CONFIG.IMAGES_PATH + row.filename
                }));

                // Load audio playlist
                let audioCount = 0;
                try {
                    const audioData = await loadCSV(CONFIG.AUDIO_CSV);
                    CONFIG.AUDIO_PLAYLIST = audioData.map(row => ({
                        filename: row.filename,
                        name: row.name || row.filename,
                        artist: row.artist || 'Unknown',
                        duration: parseInt(row.duration) || 0,
                        category: row.category || 'music',
                        path: CONFIG.AUDIO_PATH + row.filename
                    }));
                    audioCount = CONFIG.AUDIO_PLAYLIST.length;
                } catch (error) {
                    console.warn('‚ö†Ô∏è No audio playlist found');
                    CONFIG.AUDIO_PLAYLIST = [];
                }

                dataLoaded = true;
                updateDataStatus(`‚úÖ ƒê√£ t·∫£i ${CONFIG.WORDS.length} t·ª´, ${CONFIG.IMAGES.length} h√¨nh, ${audioCount} nh·∫°c`);
                console.log('üìä Data loaded:', {
                    words: CONFIG.WORDS.length,
                    images: CONFIG.IMAGES.length,
                    audio: audioCount
                });

            } catch (error) {
                console.error('‚ùå L·ªói t·∫£i d·ªØ li·ªáu:', error);
                updateDataStatus('‚ùå L·ªói t·∫£i d·ªØ li·ªáu');

                // Fallback data
                CONFIG.WORDS = [
                    { text: 'Hello', category: 'greeting', hue: 0 },
                    { text: 'World', category: 'noun', hue: 120 },
                    { text: 'Three.js', category: 'tech', hue: 240 }
                ];
                CONFIG.IMAGES = [];
            }
        }

        /**
         * Load CSV file
         */
        async function loadCSV(filepath) {
            const response = await fetch(filepath);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const text = await response.text();
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',');

            return lines.slice(1).map(line => {
                const values = line.split(',');
                const obj = {};
                headers.forEach((header, index) => {
                    obj[header.trim()] = values[index] ? values[index].trim() : '';
                });
                return obj;
            });
        }

        /**
         * Kh·ªüi t·∫°o h·ªá th·ªëng nh·∫°c
         */
        async function initMusicSystem() {
            // Kh·ªüi t·∫°o Ambient Music Generator
            if (typeof AmbientMusicGenerator !== 'undefined') {
                musicGenerator = new AmbientMusicGenerator();
                console.log('üéπ Ambient Music Generator initialized');
            } else {
                console.warn('‚ö†Ô∏è Ambient Music Generator not available');
            }

            // Kh·ªüi t·∫°o MP3 Player
            if (typeof MP3AudioPlayer !== 'undefined') {
                mp3Player = new MP3AudioPlayer();

                console.log('üîç Checking audio playlist:', CONFIG.AUDIO_PLAYLIST);

                if (CONFIG.AUDIO_PLAYLIST && CONFIG.AUDIO_PLAYLIST.length > 0) {
                    console.log('üéµ Initializing MP3 Player with tracks:');
                    CONFIG.AUDIO_PLAYLIST.forEach((track, index) => {
                        console.log(`  Track ${index + 1}: ${track.name} (${track.path})`);
                    });

                    const success = await mp3Player.init(CONFIG.AUDIO_PLAYLIST);
                    if (success) {
                        console.log('‚úÖ MP3 Player initialized successfully with', CONFIG.AUDIO_PLAYLIST.length, 'tracks');
                        updateMusicUI();
                    } else {
                        console.error('‚ùå MP3 Player initialization failed');
                        updateDataStatus('‚ùå L·ªói kh·ªüi t·∫°o MP3 player');
                    }
                } else {
                    console.log('‚ö†Ô∏è No audio tracks found in playlist');
                    updateDataStatus('‚ö†Ô∏è Kh√¥ng c√≥ file MP3');
                }
            } else {
                console.warn('‚ö†Ô∏è MP3 Player class not available');
            }
        }

        /**
         * C·∫≠p nh·∫≠t tr·∫°ng th√°i data
         */
        function updateDataStatus(message) {
            const statusElement = document.getElementById('data-status');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }

        /**
         * T·∫°o texture t·ª´ canvas cho vƒÉn b·∫£n (trong su·ªët, kh√¥ng background)
         */
        function createTextTexture(text, hue) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // K√≠ch th∆∞·ªõc canvas cao ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng
            canvas.width = 512;
            canvas.height = 512;

            // X√≥a canvas (trong su·ªët)
            ctx.clearRect(0, 0, 512, 512);

            // Thi·∫øt l·∫≠p font
            ctx.font = `bold ${CONFIG.FONT_SIZE}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // T·∫°o hi·ªáu ·ª©ng glow m·∫°nh h∆°n
            ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // V·∫Ω outline ƒë·ªÉ text n·ªïi b·∫≠t h∆°n
            ctx.strokeStyle = `hsl(${hue}, 100%, 80%)`;
            ctx.lineWidth = 3;
            ctx.strokeText(text, 256, 256);

            // V·∫Ω text ch√≠nh v·ªõi m√†u s√°ng
            ctx.fillStyle = `hsl(${hue}, 100%, 90%)`;
            ctx.fillText(text, 256, 256);

            return canvas;
        }

        /**
         * T·∫°o texture h√¨nh ·∫£nh ƒë∆°n gi·∫£n (geometric shapes)
         */
        function createImageTexture(type, hue) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = 512;
            canvas.height = 512;

            // Background gradient
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.9)`);
            gradient.addColorStop(1, `hsla(${hue}, 60%, 30%, 0.3)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // V·∫Ω shape d·ª±a tr√™n type
            ctx.fillStyle = `hsl(${hue}, 90%, 80%)`;
            ctx.strokeStyle = `hsl(${hue}, 100%, 90%)`;
            ctx.lineWidth = 8;

            const centerX = 256;
            const centerY = 256;
            const size = 150;

            switch(type) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;

                case 'square':
                    ctx.fillRect(centerX - size, centerY - size, size * 2, size * 2);
                    ctx.strokeRect(centerX - size, centerY - size, size * 2, size * 2);
                    break;

                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - size);
                    ctx.lineTo(centerX - size, centerY + size);
                    ctx.lineTo(centerX + size, centerY + size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;

                case 'star':
                    drawStar(ctx, centerX, centerY, 5, size, size * 0.5);
                    ctx.fill();
                    ctx.stroke();
                    break;
            }

            return canvas;
        }

        /**
         * V·∫Ω h√¨nh sao
         */
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);

            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }

            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
        }

        /**
         * T·∫°o ƒë·ªëi t∆∞·ª£ng 3D (vƒÉn b·∫£n ho·∫∑c h√¨nh ·∫£nh)
         */
        function createObject(content, type, hue, imagePath = null) {
            let texture;

            if (type === 'text') {
                texture = new THREE.CanvasTexture(createTextTexture(content, hue));
            } else if (type === 'image' && imagePath) {
                // Load image t·ª´ file
                texture = new THREE.TextureLoader().load(
                    imagePath,
                    function(loadedTexture) {
                        console.log(`‚úÖ Loaded image: ${imagePath}`);
                    },
                    undefined,
                    function(error) {
                        console.warn(`‚ö†Ô∏è Failed to load image: ${imagePath}`, error);
                    }
                );
            } else {
                // Fallback to generated shapes
                texture = new THREE.CanvasTexture(createImageTexture(content, hue));
            }

            texture.needsUpdate = true;

            // T·∫°o material v·ªõi hi·ªáu ·ª©ng emissive
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.1,
                emissive: new THREE.Color().setHSL(hue / 360, 0.6, 0.2),
                emissiveIntensity: 0.4
            });

            // T·∫°o geometry
            const size = CONFIG.OBJECT_SIZE.min + Math.random() * (CONFIG.OBJECT_SIZE.max - CONFIG.OBJECT_SIZE.min);
            const geometry = new THREE.PlaneGeometry(size, size);

            // T·∫°o mesh
            const mesh = new THREE.Mesh(geometry, material);

            // V·ªã tr√≠ ng·∫´u nhi√™n tr√™n h√¨nh c·∫ßu (spherical distribution)
            const radius = CONFIG.SPREAD_AREA * 0.8;
            const theta = Math.random() * Math.PI * 2; // G√≥c ngang (0-360¬∞)
            const phi = Math.acos(2 * Math.random() - 1); // G√≥c d·ªçc (ph√¢n b·ªë ƒë·ªÅu tr√™n c·∫ßu)

            mesh.position.x = radius * Math.sin(phi) * Math.cos(theta);
            mesh.position.y = CONFIG.RESPAWN_Y + Math.random() * 20; // M·∫∑c ƒë·ªãnh, s·∫Ω ƒë∆∞·ª£c override
            mesh.position.z = radius * Math.sin(phi) * Math.sin(theta);

            // Th√™m th√¥ng tin metadata
            mesh.userData = {
                content: content,
                type: type,
                hue: hue,
                originalScale: 1,
                fallSpeed: CONFIG.FALL_SPEED.min + Math.random() * (CONFIG.FALL_SPEED.max - CONFIG.FALL_SPEED.min),
                isPaused: false,
                isSelected: false,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };

            return mesh;
        }

        /**
         * T·∫°o c√°c ƒë·ªëi t∆∞·ª£ng ban ƒë·∫ßu - ph√¢n b·ªë ƒë·ªÅu t·ª´ tr√™n xu·ªëng
         */
        function createInitialObjects() {
            const count = parseInt(document.getElementById('object-count').value);

            for (let i = 0; i < count; i++) {
                let content, type, hue, imagePath = null;

                if (currentMode === 'text') {
                    if (CONFIG.WORDS.length > 0) {
                        const wordData = CONFIG.WORDS[Math.floor(Math.random() * CONFIG.WORDS.length)];
                        content = wordData.text || wordData; // Fallback n·∫øu wordData l√† string
                        hue = wordData.hue || (i / count) * 360;
                        type = 'text';
                    } else {
                        content = 'Hello';
                        hue = (i / count) * 360;
                        type = 'text';
                    }
                } else if (currentMode === 'images') {
                    if (CONFIG.IMAGES.length > 0) {
                        const imageData = CONFIG.IMAGES[Math.floor(Math.random() * CONFIG.IMAGES.length)];
                        content = imageData.name;
                        hue = imageData.hue;
                        imagePath = imageData.path;
                        type = 'image';
                    } else {
                        const shapes = ['circle', 'square', 'triangle', 'star'];
                        content = shapes[Math.floor(Math.random() * shapes.length)];
                        hue = (i / count) * 360;
                        type = 'image';
                    }
                } else { // mixed
                    if (Math.random() > 0.5 && CONFIG.WORDS.length > 0) {
                        const wordData = CONFIG.WORDS[Math.floor(Math.random() * CONFIG.WORDS.length)];
                        content = wordData.text || wordData; // Fallback n·∫øu wordData l√† string
                        hue = wordData.hue || (i / count) * 360;
                        type = 'text';
                    } else if (CONFIG.IMAGES.length > 0) {
                        const imageData = CONFIG.IMAGES[Math.floor(Math.random() * CONFIG.IMAGES.length)];
                        content = imageData.name || imageData;
                        hue = imageData.hue || (i / count) * 360;
                        imagePath = imageData.path;
                        type = 'image';
                    } else {
                        content = 'Hello';
                        hue = (i / count) * 360;
                        type = 'text';
                    }
                }

                const obj = createObject(content, type, hue, imagePath);

                // Ph√¢n b·ªë ƒë·ªÅu t·ª´ tr√™n xu·ªëng ƒë·ªÉ kh√¥ng c√≥ kho·∫£ng tr·ªëng
                const fallDistance = CONFIG.RESPAWN_Y - CONFIG.DESPAWN_Y;
                const progress = i / count;
                obj.position.y = CONFIG.DESPAWN_Y + (fallDistance * progress) + Math.random() * 5;

                // Hi·ªáu ·ª©ng xu·∫•t hi·ªán: b·∫Øt ƒë·∫ßu t·ª´ scale 0 v√† tƒÉng d·∫ßn
                obj.scale.setScalar(0);
                obj.userData.spawnTime = Date.now() + (i * 30); // Delay m·ªói object 30ms
                obj.userData.isSpawning = true;

                scene.add(obj);
                objects.push(obj);
            }

            updateObjectCount();
            console.log(`‚úÖ T·∫°o ${count} ƒë·ªëi t∆∞·ª£ng ph√¢n b·ªë ƒë·ªÅu t·ª´ tr√™n xu·ªëng`);
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán click chu·ªôt
         */
        function onMouseClick(event) {
            event.preventDefault();

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                // B·∫•m v√†o ph·∫ßn t·ª≠ - d·ª´ng v√† cho ph√©p zoom
                selectObject(intersects[0].object);
            } else {
                // B·∫•m ra ngo√†i - tr·ªü v·ªÅ b√¨nh th∆∞·ªùng
                deselectObject();
            }
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán di chuy·ªÉn chu·ªôt
         */
        function onMouseMove(event) {
            // Kh√¥ng c·∫ßn x·ª≠ l√Ω drag ƒë·ªÉ scale n·ªØa
            // Ch·ªâ d√πng scroll wheel ƒë·ªÉ zoom
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán scroll wheel
         */
        function onMouseWheel(event) {
            event.preventDefault();

            if (selectedObject) {
                // Zoom ph·∫ßn t·ª≠ ƒë∆∞·ª£c ch·ªçn
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                const currentScale = selectedObject.scale.x;
                const newScale = THREE.MathUtils.clamp(
                    currentScale + delta,
                    CONFIG.SCALE_RANGE.min,
                    CONFIG.SCALE_RANGE.max
                );
                selectedObject.scale.setScalar(newScale);

                console.log(`üîç Zoom object: ${newScale.toFixed(2)}x`);
            }
            // N·∫øu kh√¥ng c√≥ object ƒë∆∞·ª£c ch·ªçn, ƒë·ªÉ OrbitControls x·ª≠ l√Ω zoom camera
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán touch start
         */
        function onTouchStart(event) {
            event.preventDefault();

            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(objects);

                if (intersects.length > 0) {
                    // Touch v√†o ph·∫ßn t·ª≠ - d·ª´ng v√† cho ph√©p zoom b·∫±ng pinch
                    selectObject(intersects[0].object);
                } else {
                    // Touch ra ngo√†i - tr·ªü v·ªÅ b√¨nh th∆∞·ªùng
                    deselectObject();
                }
            }
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán touch move (cho pinch zoom)
         */
        function onTouchMove(event) {
            event.preventDefault();

            // X·ª≠ l√Ω pinch zoom cho object ƒë∆∞·ª£c ch·ªçn
            if (selectedObject && event.touches.length === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];

                const distance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                if (!selectedObject.userData.lastTouchDistance) {
                    selectedObject.userData.lastTouchDistance = distance;
                    return;
                }

                const delta = (distance - selectedObject.userData.lastTouchDistance) * 0.01;
                const currentScale = selectedObject.scale.x;
                const newScale = THREE.MathUtils.clamp(
                    currentScale + delta,
                    CONFIG.SCALE_RANGE.min,
                    CONFIG.SCALE_RANGE.max
                );

                selectedObject.scale.setScalar(newScale);
                selectedObject.userData.lastTouchDistance = distance;
            }
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán touch end
         */
        function onTouchEnd(event) {
            event.preventDefault();

            if (selectedObject) {
                selectedObject.userData.lastTouchDistance = null;
            }

            // Kh√¥ng t·ª± ƒë·ªông deselect khi touch end
            // Ch·ªâ deselect khi touch v√†o ch·ªó kh√°c
        }

        /**
         * Ch·ªçn ƒë·ªëi t∆∞·ª£ng
         */
        function selectObject(obj) {
            // B·ªè ch·ªçn ƒë·ªëi t∆∞·ª£ng c≈© n·∫øu c√≥
            if (selectedObject && selectedObject !== obj) {
                selectedObject.userData.isPaused = false;
                selectedObject.userData.isSelected = false;
                selectedObject.scale.setScalar(1);
            }

            // Ch·ªçn ƒë·ªëi t∆∞·ª£ng m·ªõi
            selectedObject = obj;
            selectedObject.userData.isPaused = true;  // D·ª´ng r∆°i
            selectedObject.userData.isSelected = true;
            selectedObject.scale.setScalar(1.2);  // Scale nh·∫π ƒë·ªÉ hi·ªÉn th·ªã ƒë∆∞·ª£c ch·ªçn

            // C·∫≠p nh·∫≠t UI
            const content = obj.userData.content;
            const type = obj.userData.type;
            document.getElementById('selected-object').textContent = `${type}: ${content}`;

            console.log(`üéØ Selected: ${content} (${type})`);
        }

        /**
         * B·ªè ch·ªçn ƒë·ªëi t∆∞·ª£ng
         */
        function deselectObject() {
            if (selectedObject) {
                selectedObject.userData.isPaused = false;  // Ti·∫øp t·ª•c r∆°i
                selectedObject.userData.isSelected = false;
                selectedObject.scale.setScalar(1);  // Tr·ªü v·ªÅ k√≠ch th∆∞·ªõc ban ƒë·∫ßu
                selectedObject.userData.lastTouchDistance = null;  // Reset touch data

                console.log(`üîÑ Deselected: ${selectedObject.userData.content}`);
                selectedObject = null;
            }

            document.getElementById('selected-object').textContent = 'Kh√¥ng c√≥';
        }

        /**
         * Toggle nh·∫°c n·ªÅn
         */
        async function toggleMusic() {
            try {
                if (currentMusicType === 'ambient') {
                    if (!musicGenerator) {
                        console.warn('‚ö†Ô∏è Ambient music not available');
                        return;
                    }

                    if (isMusicPlaying) {
                        musicGenerator.stop();
                        isMusicPlaying = false;
                        document.getElementById('toggle-music').textContent = 'üéµ B·∫≠t nh·∫°c';
                        console.log('üîá Ambient music stopped');
                    } else {
                        const started = await musicGenerator.start();
                        if (started) {
                            isMusicPlaying = true;
                            document.getElementById('toggle-music').textContent = 'üîá T·∫Øt nh·∫°c';
                            console.log('üéµ Ambient music started');
                        }
                    }
                } else { // MP3
                    if (!mp3Player) {
                        console.warn('‚ö†Ô∏è MP3 player not available');
                        updateDataStatus('‚ùå MP3 player kh√¥ng c√≥ s·∫µn');
                        return;
                    }

                    if (!mp3Player.audio) {
                        console.warn('‚ö†Ô∏è No audio loaded in MP3 player');
                        updateDataStatus('‚ùå Kh√¥ng c√≥ file MP3 n√†o ƒë∆∞·ª£c t·∫£i');

                        // Th·ª≠ reload audio
                        if (CONFIG.AUDIO_PLAYLIST && CONFIG.AUDIO_PLAYLIST.length > 0) {
                            console.log('üîÑ Trying to reload audio...');
                            const success = await mp3Player.init(CONFIG.AUDIO_PLAYLIST);
                            if (!success) {
                                updateDataStatus('‚ùå Kh√¥ng th·ªÉ t·∫£i file MP3');
                                return;
                            }
                        } else {
                            updateDataStatus('‚ùå Kh√¥ng c√≥ file MP3 trong playlist');
                            return;
                        }
                    }

                    if (isMusicPlaying) {
                        mp3Player.pause();
                        isMusicPlaying = false;
                        document.getElementById('toggle-music').textContent = 'üéµ B·∫≠t nh·∫°c';
                        console.log('üîá MP3 paused');
                    } else {
                        console.log('üéµ Attempting to play MP3...');
                        const started = await mp3Player.play();
                        if (started) {
                            isMusicPlaying = true;
                            document.getElementById('toggle-music').textContent = 'üîá T·∫Øt nh·∫°c';
                            updateCurrentTrackInfo();
                            updateDataStatus('üéµ ƒêang ph√°t MP3');
                            console.log('üéµ MP3 playing successfully');
                        } else {
                            console.error('‚ùå Failed to start MP3 playback');
                            updateDataStatus('‚ùå Kh√¥ng th·ªÉ ph√°t MP3');
                        }
                    }
                }
            } catch (error) {
                console.error('‚ùå Music error:', error);
            }
        }

        /**
         * Chuy·ªÉn b√†i ti·∫øp theo (ch·ªâ cho MP3)
         */
        async function nextTrack() {
            if (currentMusicType === 'mp3' && mp3Player) {
                await mp3Player.nextTrack();
                updateCurrentTrackInfo();
            }
        }

        /**
         * Thay ƒë·ªïi lo·∫°i nh·∫°c
         */
        function onMusicTypeChange(event) {
            const newType = event.target.value;

            // D·ª´ng nh·∫°c hi·ªán t·∫°i
            if (isMusicPlaying) {
                if (currentMusicType === 'ambient' && musicGenerator) {
                    musicGenerator.stop();
                } else if (currentMusicType === 'mp3' && mp3Player) {
                    mp3Player.pause();
                }
                isMusicPlaying = false;
            }

            currentMusicType = newType;
            updateMusicUI();

            document.getElementById('toggle-music').textContent = 'üéµ B·∫≠t nh·∫°c';
            console.log('üîÑ Switched to', newType, 'music');
        }

        /**
         * C·∫≠p nh·∫≠t UI theo lo·∫°i nh·∫°c
         */
        function updateMusicUI() {
            const nextTrackBtn = document.getElementById('next-track');
            const trackInfo = document.getElementById('current-track-info');

            if (currentMusicType === 'mp3') {
                nextTrackBtn.style.display = 'block';
                trackInfo.style.display = 'block';
                updateCurrentTrackInfo();
            } else {
                nextTrackBtn.style.display = 'none';
                trackInfo.style.display = 'none';
            }
        }

        /**
         * C·∫≠p nh·∫≠t th√¥ng tin b√†i h√°t hi·ªán t·∫°i
         */
        function updateCurrentTrackInfo() {
            if (currentMusicType === 'mp3' && mp3Player) {
                const track = mp3Player.getCurrentTrack();
                const trackElement = document.getElementById('current-track');

                if (track) {
                    trackElement.textContent = `${track.name} - ${track.artist}`;
                } else {
                    trackElement.textContent = 'Kh√¥ng c√≥';
                }
            }
        }

        /**
         * Thay ƒë·ªïi √¢m l∆∞·ª£ng nh·∫°c
         */
        function onVolumeChange(event) {
            const volume = parseFloat(event.target.value);
            document.getElementById('volume-value').textContent = Math.round(volume * 100) + '%';

            if (currentMusicType === 'ambient' && musicGenerator) {
                musicGenerator.setVolume(volume);
            } else if (currentMusicType === 'mp3' && mp3Player) {
                mp3Player.setVolume(volume);
            }
        }

        /**
         * Reload data t·ª´ files
         */
        async function reloadData() {
            updateDataStatus('ƒêang t·∫£i l·∫°i...');
            await loadDataFiles();

            // Clear existing objects and recreate
            clearAllObjects();
            createInitialObjects();
        }

        /**
         * Hi·ªán settings (controls + info)
         */
        function showSettings() {
            const controlsPanel = document.getElementById('controls');
            const infoPanel = document.getElementById('info');
            const mainBtn = document.getElementById('main-settings');

            // Hi·ªán c·∫£ controls v√† info
            controlsVisible = true;
            infoVisible = true;

            controlsPanel.classList.add('visible');
            infoPanel.classList.add('visible');

            // ·∫®n main settings button
            mainBtn.style.display = 'none';

            console.log('üì± Settings panels shown');
        }

        /**
         * Toggle hi·ªÉn th·ªã controls panel
         */
        function toggleControls() {
            const controlsPanel = document.getElementById('controls');
            const mainBtn = document.getElementById('main-settings');

            controlsVisible = !controlsVisible;

            if (controlsVisible) {
                controlsPanel.classList.add('visible');
                console.log('üì± Controls panel shown');
            } else {
                controlsPanel.classList.remove('visible');

                // N·∫øu c·∫£ controls v√† info ƒë·ªÅu ·∫©n, hi·ªán main settings button
                if (!infoVisible) {
                    mainBtn.style.display = 'block';
                }
                console.log('üì± Controls panel hidden');
            }
        }

        /**
         * Toggle hi·ªÉn th·ªã info panel
         */
        function toggleInfo() {
            const infoPanel = document.getElementById('info');
            const toggleBtn = document.getElementById('toggle-info');
            const mainBtn = document.getElementById('main-settings');

            infoVisible = !infoVisible;

            if (infoVisible) {
                infoPanel.classList.add('visible');
                toggleBtn.textContent = '‚ùì';
                toggleBtn.title = '·∫®n h∆∞·ªõng d·∫´n';
                console.log('üì± Info panel shown');
            } else {
                infoPanel.classList.remove('visible');
                toggleBtn.textContent = '‚ùå';
                toggleBtn.title = 'Hi·ªán h∆∞·ªõng d·∫´n';

                // N·∫øu c·∫£ controls v√† info ƒë·ªÅu ·∫©n, hi·ªán main settings button
                if (!controlsVisible) {
                    mainBtn.style.display = 'block';
                }
                console.log('üì± Info panel hidden');
            }
        }

        /**
         * X·ª≠ l√Ω keyboard shortcuts
         */
        function onKeyDown(event) {
            // Kh√¥ng x·ª≠ l√Ω n·∫øu ƒëang focus v√†o input
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT') {
                return;
            }

            switch(event.key.toLowerCase()) {
                case 's':
                    // S ƒë·ªÉ m·ªü settings
                    if (!controlsVisible && !infoVisible) {
                        showSettings();
                    }
                    break;
                case 'c':
                    toggleControls();
                    break;
                case 'h':
                case '?':
                    toggleInfo();
                    break;
                case ' ':
                    event.preventDefault();
                    toggleMusic();
                    break;
                case 'r':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        reloadData();
                    }
                    break;
                case 'escape':
                    deselectObject();
                    break;
            }
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi ch·∫ø ƒë·ªô hi·ªÉn th·ªã
         */
        function onModeChange(event) {
            currentMode = event.target.value;
            clearAllObjects();
            createInitialObjects();
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi s·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng
         */
        function onObjectCountChange(event) {
            const value = event.target.value;
            document.getElementById('count-value').textContent = value;
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi t·ªëc ƒë·ªô r∆°i
         */
        function onFallSpeedChange(event) {
            fallSpeedMultiplier = parseInt(event.target.value);
            document.getElementById('speed-value').textContent = fallSpeedMultiplier;
        }

        /**
         * Th√™m ƒë·ªëi t∆∞·ª£ng m·ªõi v·ªõi ph√¢n b·ªë ng·∫´u nhi√™n
         */
        function addObjects() {
            const addCount = Math.min(20, parseInt(document.getElementById('object-count').value));

            for (let i = 0; i < addCount; i++) {
                let content, type;
                const hue = Math.random() * 360;

                if (currentMode === 'text') {
                    if (CONFIG.WORDS.length > 0) {
                        const wordData = CONFIG.WORDS[Math.floor(Math.random() * CONFIG.WORDS.length)];
                        content = wordData.text || wordData; // Fallback n·∫øu wordData l√† string
                        type = 'text';
                    } else {
                        content = 'Hello';
                        type = 'text';
                    }
                } else if (currentMode === 'images') {
                    if (CONFIG.IMAGES.length > 0) {
                        const imageData = CONFIG.IMAGES[Math.floor(Math.random() * CONFIG.IMAGES.length)];
                        content = imageData.name || imageData;
                        type = 'image';
                    } else {
                        const shapes = ['circle', 'square', 'triangle', 'star'];
                        content = shapes[Math.floor(Math.random() * shapes.length)];
                        type = 'image';
                    }
                } else {
                    if (Math.random() > 0.5 && CONFIG.WORDS.length > 0) {
                        const wordData = CONFIG.WORDS[Math.floor(Math.random() * CONFIG.WORDS.length)];
                        content = wordData.text || wordData;
                        type = 'text';
                    } else if (CONFIG.IMAGES.length > 0) {
                        const imageData = CONFIG.IMAGES[Math.floor(Math.random() * CONFIG.IMAGES.length)];
                        content = imageData.name || imageData;
                        type = 'image';
                    } else {
                        content = 'Hello';
                        type = 'text';
                    }
                }

                const obj = createObject(content, type, hue);

                // ƒê·ªëi t∆∞·ª£ng m·ªõi xu·∫•t hi·ªán ·ªü tr√™n c√πng
                obj.position.y = CONFIG.RESPAWN_Y + Math.random() * 20;

                scene.add(obj);
                objects.push(obj);
            }

            updateObjectCount();
            console.log(`‚ûï Th√™m ${addCount} ƒë·ªëi t∆∞·ª£ng m·ªõi`);
        }

        /**
         * X√≥a t·∫•t c·∫£ ƒë·ªëi t∆∞·ª£ng
         */
        function clearAllObjects() {
            objects.forEach(obj => {
                scene.remove(obj);
                obj.geometry.dispose();
                obj.material.dispose();
                if (obj.material.map) {
                    obj.material.map.dispose();
                }
            });

            objects = [];
            selectedObject = null;
            updateObjectCount();
            document.getElementById('selected-object').textContent = 'Kh√¥ng c√≥';
        }

        /**
         * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng hi·ªÉn th·ªã
         */
        function updateObjectCount() {
            // C·∫≠p nh·∫≠t trong UI info n·∫øu c√≥ element t∆∞∆°ng ·ª©ng
            const objectCountElement = document.querySelector('#info .value-display');
            if (objectCountElement) {
                objectCountElement.textContent = objects.length;
            }
        }

        /**
         * ·∫®n loading screen
         */
        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }

        /**
         * Hi·ªÉn th·ªã l·ªói WebGL
         */
        function showWebGLError() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('webgl-error').style.display = 'block';
        }

        /**
         * V√≤ng l·∫∑p animation ch√≠nh
         */
        function animate() {
            requestAnimationFrame(animate);

            // C·∫≠p nh·∫≠t FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps-counter').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }

            // C·∫≠p nh·∫≠t hi·ªáu ·ª©ng l·∫•p l√°nh c·ªßa sao
            if (scene.userData.starsMaterial) {
                scene.userData.starsMaterial.uniforms.time.value = currentTime * 0.001;
            }

            // C·∫≠p nh·∫≠t ƒë·ªëi t∆∞·ª£ng
            updateObjects();

            // C·∫≠p nh·∫≠t controls
            controls.update();

            // Render scene
            renderer.render(scene, camera);
        }

        /**
         * C·∫≠p nh·∫≠t t·∫•t c·∫£ ƒë·ªëi t∆∞·ª£ng trong scene
         */
        function updateObjects() {
            const currentTime = Date.now();

            objects.forEach((obj, index) => {
                // X·ª≠ l√Ω hi·ªáu ·ª©ng spawn
                if (obj.userData.isSpawning) {
                    if (currentTime >= obj.userData.spawnTime) {
                        const spawnDuration = 500; // 500ms ƒë·ªÉ scale t·ª´ 0 l√™n 1
                        const elapsed = currentTime - obj.userData.spawnTime;
                        const progress = Math.min(elapsed / spawnDuration, 1);

                        // Easing function cho hi·ªáu ·ª©ng m∆∞·ª£t m√†
                        const easeOut = 1 - Math.pow(1 - progress, 3);
                        obj.scale.setScalar(easeOut);

                        if (progress >= 1) {
                            obj.userData.isSpawning = false;
                        }
                    }
                    return; // Kh√¥ng r∆°i khi ƒëang spawn
                }

                // Billboarding - lu√¥n h∆∞·ªõng v·ªÅ camera
                obj.lookAt(camera.position);

                // R∆°i xu·ªëng theo tr·ª•c Y th·∫ø gi·ªõi (kh√¥ng b·ªã ·∫£nh h∆∞·ªüng b·ªüi camera)
                if (!obj.userData.isPaused) {
                    // Ch·ªâ thay ƒë·ªïi Y, gi·ªØ nguy√™n X v√† Z
                    obj.position.y -= obj.userData.fallSpeed * fallSpeedMultiplier;

                    // Respawn khi r∆°i qu√° th·∫•p - t·∫°o l·∫°i v·ªã tr√≠ spherical
                    if (obj.position.y < CONFIG.DESPAWN_Y) {
                        // T·∫°o v·ªã tr√≠ m·ªõi tr√™n h√¨nh c·∫ßu
                        const radius = CONFIG.SPREAD_AREA * 0.8;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);

                        obj.position.x = radius * Math.sin(phi) * Math.cos(theta);
                        obj.position.y = CONFIG.RESPAWN_Y + Math.random() * 20;
                        obj.position.z = radius * Math.sin(phi) * Math.sin(theta);
                    }
                }

                // Hi·ªáu ·ª©ng glow nh·∫π
                if (obj.userData.isSelected) {
                    obj.material.emissiveIntensity = 0.6 + Math.sin(Date.now() * 0.005) * 0.2;
                } else {
                    obj.material.emissiveIntensity = 0.4;
                }
            });
        }


    </script>
</body>
</html>
