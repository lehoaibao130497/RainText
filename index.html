<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rain Effect - VƒÉn b·∫£n & H√¨nh ·∫£nh r∆°i</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
            user-select: none;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ffff;
        }

        #loading.hidden {
            display: none;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #00ffff;
            min-width: 280px;
            max-width: 350px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 10;
            transition: transform 0.3s ease, opacity 0.3s ease;
            /* ·∫®n m·∫∑c ƒë·ªãnh */
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }

        #controls.visible {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto;
        }

        /* Custom scrollbar cho controls */
        #controls::-webkit-scrollbar {
            width: 8px;
        }

        #controls::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #controls::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.6);
            border-radius: 4px;
        }

        #controls::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 255, 0.8);
        }



        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ff6b6b;
            max-width: 300px;
            font-size: 14px;
            z-index: 10;
            transition: transform 0.3s ease, opacity 0.3s ease;
            /* ·∫®n m·∫∑c ƒë·ªãnh */
            transform: translateX(100%);
            opacity: 0;
            pointer-events: none;
        }

        #info.visible {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto;
        }



        #webgl-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            display: none;
            z-index: 200;
        }

        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
        }

        .control-group {
            margin-bottom: 15px;
        }

        /* MP3 Controls styling */
        #mp3-controls {
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: rgba(0, 255, 255, 0.05);
        }

        #mp3-controls button {
            margin: 2px;
            padding: 8px 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        #mp3-controls select {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 4px;
            padding: 5px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ffff;
            font-weight: bold;
        }

        select, button, input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #00ffff;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 14px;
        }

        button {
            background: linear-gradient(45deg, #00ffff, #ff6b6b);
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .status {
            color: #ff6b6b;
            font-weight: bold;
        }

        .value-display {
            color: #00ffff;
            font-weight: bold;
        }

        /* Main settings button */
        #main-settings:hover {
            background: rgba(0, 255, 255, 1) !important;
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.5);
        }

        /* Toggle buttons trong controls */
        #toggle-info:hover {
            /*background: rgba(255, 107, 107, 1) !important;*/
            transform: scale(1.05);
        }

        #toggle-controls:hover {
            /*background: rgba(255, 193, 7, 1) !important;*/
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            #controls {
                top: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                padding: 15px;
            }
            
            #info {
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            #controls {
                font-size: 12px;
            }
            
            select, button, input[type="range"] {
                font-size: 12px;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <div id="loading">
            <div class="spinner"></div>
            <h3>ƒêang t·∫£i c·∫£nh 3D...</h3>
            <p>Chu·∫©n b·ªã c√°c ƒë·ªëi t∆∞·ª£ng r∆°i</p>
        </div>

        <!-- Start overlay for user interaction -->
        <div id="start-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); z-index: 999; align-items: center; justify-content: center; color: white; font-family: Arial, sans-serif;">
            <div style="text-align: center; max-width: 400px; padding: 40px;">
                <div style="font-size: 60px; margin-bottom: 20px; animation: pulse 2s infinite;">üéµ</div>
                <h2 style="color: #00ffff; margin-bottom: 15px; font-size: 28px;">Ch√†o m·ª´ng ƒë·∫øn v·ªõi Rain Text 3D!</h2>
                <p style="color: #ccc; margin-bottom: 30px; line-height: 1.6; font-size: 16px;">
                    Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu tr·∫£i nghi·ªám v·ªõi hi·ªáu ·ª©ng 3D v√† nh·∫°c n·ªÅn tuy·ªát v·ªùi.
                </p>
                <button id="start-experience" style="background: linear-gradient(45deg, #00ffff, #00cc99); color: black; border: none; padding: 15px 30px; border-radius: 25px; font-weight: bold; cursor: pointer; font-size: 18px; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);">
                    üöÄ B·∫Øt ƒë·∫ßu tr·∫£i nghi·ªám
                </button>
            </div>
        </div>

        <!-- Main Settings Button -->
        <button id="main-settings" style="position: absolute; top: 20px; left: 20px; background: transparent; color: white; border: none; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; z-index: 11; min-width: auto; width: auto;" title="M·ªü c√†i ƒë·∫∑t">‚öôÔ∏è Settings</button>





        <div id="controls">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #00ffff; margin: 0;">üéÆ ƒêi·ªÅu khi·ªÉn</h3>
                <div>
                    <button id="toggle-info" title="·∫®n/Hi·ªán h∆∞·ªõng d·∫´n" style="background: transparent; color: white; border: none; padding: 5px; border-radius: 5px; cursor: pointer; margin-right: 8px; font-size: 14px;">‚ùì</button>
                    <button id="toggle-controls" title="·∫®n ƒëi·ªÅu khi·ªÉn" style="background: transparent; color: black; border: none; padding: 5px; border-radius: 5px; cursor: pointer; font-size: 14px;">üîΩ</button>
                </div>
            </div>
            
            <div class="control-group">
                <label for="mode-select">Ch·∫ø ƒë·ªô hi·ªÉn th·ªã:</label>
                <select id="mode-select">
                    <option value="text">üìù VƒÉn b·∫£n</option>
                    <option value="images">üñºÔ∏è H√¨nh ·∫£nh</option>
                    <option value="mixed">üé≠ K·∫øt h·ª£p</option>
                </select>
            </div>

            <div class="control-group">
                <label for="object-count">S·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng: <span id="count-value" class="value-display">120</span></label>
                <input type="range" id="object-count" min="20" max="500" value="120">
            </div>

            <div class="control-group">
                <label for="fall-speed">T·ªëc ƒë·ªô r∆°i: <span id="speed-value" class="value-display">5</span></label>
                <input type="range" id="fall-speed" min="1" max="10" step="1" value="5">
            </div>

            <div class="control-group">
                <label for="object-spacing">Kho·∫£ng c√°ch: <span id="spacing-value" class="value-display">100</span></label>
                <input type="range" id="object-spacing" min="20" max="200" step="10" value="100">
            </div>

            <div class="control-group">
                <button id="add-objects">‚ûï Th√™m ƒë·ªëi t∆∞·ª£ng</button>
            </div>

            <div class="control-group">
                <button id="clear-objects">üóëÔ∏è X√≥a t·∫•t c·∫£</button>
            </div>

            <div class="control-group">
                <button id="reload-data">üîÑ T·∫£i l·∫°i d·ªØ li·ªáu</button>
            </div>

            <div class="control-group">
                <button id="test-mp3-ui" style="background: #4CAF50; color: white;">üéµ C√†i ƒë·∫∑t MP3</button>
            </div>

            <div class="control-group">
                <label for="music-type">Lo·∫°i nh·∫°c:</label>
                <select id="music-type">
                    <option value="ambient">üéπ Ambient (Web Audio)</option>
                    <option value="mp3">üéµ MP3 Files</option>
                </select>
            </div>

            <div class="control-group">
                <button id="toggle-music">üéµ B·∫≠t/T·∫Øt nh·∫°c</button>
            </div>

            <div class="control-group" id="mp3-controls" style="display: none;">
                <h4 style="color: #00ffff; margin-bottom: 15px;">üéµ C√†i ƒë·∫∑t MP3</h4>

                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                    <button id="prev-track">‚èÆÔ∏è Tr∆∞·ªõc</button>
                    <button id="next-track">‚è≠Ô∏è Ti·∫øp</button>
                </div>

                <div style="margin-bottom: 15px;">
                    <label for="play-mode">Ch·∫ø ƒë·ªô ph√°t:</label>
                    <select id="play-mode" style="margin-left: 10px; padding: 5px;">
                        <option value="sequential">üîÑ Tu·∫ßn t·ª±</option>
                        <option value="loop">üîÅ L·∫∑p l·∫°i</option>
                        <option value="random">üîÄ Ng·∫´u nhi√™n</option>
                    </select>
                </div>

                <div style="margin-bottom: 15px;">
                    <label for="track-select">Ch·ªçn b√†i:</label>
                    <select id="track-select" style="margin-left: 10px; padding: 5px; width: 200px;">
                        <option value="">-- Ch·ªçn b√†i h√°t --</option>
                    </select>
                </div>

                <div style="margin-bottom: 15px;">
                    <label for="default-track">B√†i m·∫∑c ƒë·ªãnh khi m·ªü:</label>
                    <select id="default-track" style="margin-left: 10px; padding: 5px; width: 200px;">
                        <option value="">-- Kh√¥ng ƒë·∫∑t m·∫∑c ƒë·ªãnh --</option>
                    </select>
                </div>

                <div style="margin-bottom: 15px;">
                    <label>
                        <input type="checkbox" id="auto-play-enabled" style="width: auto; margin-right: 8px;">
                        T·ª± ƒë·ªông ph√°t nh·∫°c khi m·ªü
                    </label>
                </div>
            </div>

            <div class="control-group">
                <label for="music-volume">√Çm l∆∞·ª£ng nh·∫°c:</label>
                <input type="range" id="music-volume" min="0" max="1" step="0.1" value="0.5">
                <span id="volume-value">50%</span>
            </div>

            <div class="control-group" id="current-track-info" style="display: none;">
                <p><strong>ƒêang ph√°t:</strong></p>
                <p class="status" id="current-track">Kh√¥ng c√≥</p>
            </div>

            <div class="control-group">
                <p><strong>ƒê·ªëi t∆∞·ª£ng ƒë∆∞·ª£c ch·ªçn:</strong></p>
                <p class="status" id="selected-object">Kh√¥ng c√≥</p>
            </div>

            <div class="control-group">
                <p><strong>Tr·∫°ng th√°i:</strong></p>
                <p class="status" id="data-status">ƒêang t·∫£i...</p>
            </div>
        </div>

        <div id="info">
            <h4>üéØ H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng</h4>
            <ul style="margin: 10px 0; padding-left: 20px; font-size: 13px;">
                <li>üñ±Ô∏è <strong>K√©o chu·ªôt:</strong> Xoay camera</li>
                <li>üëÜ <strong>Click ph·∫ßn t·ª≠:</strong> D·ª´ng r∆°i</li>
                <li>üîç <strong>Scroll wheel:</strong> Zoom ph·∫ßn t·ª≠ ƒë∆∞·ª£c ch·ªçn</li>
                <li>üñ±Ô∏è <strong>Click ra ngo√†i:</strong> Tr·ªü v·ªÅ b√¨nh th∆∞·ªùng</li>
                <li>üì± <strong>Touch:</strong> Tap ch·ªçn, pinch zoom</li>
            </ul>

            <h5 style="color: #00ffff; margin: 10px 0 5px 0;">‚å®Ô∏è Ph√≠m t·∫Øt:</h5>
            <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
                <li><strong>S:</strong> M·ªü settings (khi UI ·∫©n)</li>
                <li><strong>C:</strong> ·∫®n/hi·ªán ƒëi·ªÅu khi·ªÉn</li>
                <li><strong>H ho·∫∑c ?:</strong> ·∫®n/hi·ªán h∆∞·ªõng d·∫´n</li>
                <li><strong>Space:</strong> B·∫≠t/t·∫Øt nh·∫°c</li>
                <li><strong>Ctrl+R:</strong> T·∫£i l·∫°i d·ªØ li·ªáu</li>
                <li><strong>Esc:</strong> B·ªè ch·ªçn ƒë·ªëi t∆∞·ª£ng</li>
            </ul>

            <p style="margin-top: 10px;"><strong>FPS:</strong> <span id="fps-counter" class="value-display">60</span></p>
        </div>

        <div id="webgl-error">
            <h3>‚ùå Kh√¥ng h·ªó tr·ª£ WebGL</h3>
            <p>Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ WebGL. Vui l√≤ng s·ª≠ d·ª•ng Chrome, Firefox, Safari ho·∫∑c Edge phi√™n b·∫£n m·ªõi.</p>
        </div>
    </div>

    <!-- Three.js CDN v·ªõi loading management -->
    <script>
        // Global loading state
        window.librariesLoaded = {
            threejs: false,
            orbitcontrols: false
        };

        // Load Three.js
        function loadThreeJS() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js';

                script.onload = function() {
                    console.log('‚úÖ Three.js loaded successfully');
                    window.librariesLoaded.threejs = true;
                    resolve();
                };

                script.onerror = function() {
                    console.warn('‚ö†Ô∏è Primary CDN failed, trying backup...');
                    loadThreeJSBackup().then(resolve).catch(reject);
                };

                document.head.appendChild(script);
            });
        }

        // Backup Three.js loader
        function loadThreeJSBackup() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/three@0.155.0/build/three.min.js';

                script.onload = function() {
                    console.log('‚úÖ Three.js loaded from backup CDN');
                    window.librariesLoaded.threejs = true;
                    resolve();
                };

                script.onerror = function() {
                    console.error('‚ùå All Three.js CDNs failed');
                    document.getElementById('loading').innerHTML = `
                        <h3>‚ùå L·ªói t·∫£i th∆∞ vi·ªán</h3>
                        <p>Kh√¥ng th·ªÉ t·∫£i Three.js. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet v√† th·ª≠ l·∫°i.</p>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 10px; background: #00ffff; border: none; border-radius: 5px; cursor: pointer;">üîÑ Th·ª≠ l·∫°i</button>
                    `;
                    reject(new Error('Failed to load Three.js'));
                };

                document.head.appendChild(script);
            });
        }

        // Load OrbitControls
        function loadOrbitControls() {
            return new Promise((resolve) => {
                // Try modern ES6 module first
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/three@0.155.0/examples/js/controls/OrbitControls.js';

                script.onload = function() {
                    console.log('‚úÖ OrbitControls loaded successfully');
                    window.librariesLoaded.orbitcontrols = true;
                    resolve();
                };

                script.onerror = function() {
                    console.warn('‚ö†Ô∏è Primary OrbitControls failed, trying backup...');
                    loadOrbitControlsBackup().then(resolve);
                };

                document.head.appendChild(script);
            });
        }

        // Backup OrbitControls loader
        function loadOrbitControlsBackup() {
            return new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/controls/OrbitControls.js';

                script.onload = function() {
                    console.log('‚úÖ OrbitControls loaded from backup CDN');
                    window.librariesLoaded.orbitcontrols = true;
                    resolve();
                };

                script.onerror = function() {
                    console.warn('‚ö†Ô∏è All OrbitControls CDNs failed, will use basic controls');
                    window.librariesLoaded.orbitcontrols = false;
                    resolve(); // Don't reject, just continue without OrbitControls
                };

                document.head.appendChild(script);
            });
        }

        // Load all libraries sequentially
        async function loadAllLibraries() {
            try {
                await loadThreeJS();
                await loadOrbitControls();
                console.log('üéâ All libraries loaded successfully');
                return true;
            } catch (error) {
                console.error('‚ùå Failed to load libraries:', error);
                return false;
            }
        }

        // Start loading immediately
        loadAllLibraries();
    </script>

    <!-- Audio Systems -->
    <script src="audio/ambient-music.js"></script>
    <script src="audio/mp3-player.js"></script>

    <script>
        /**
         * 3D Rain Effect Demo - VƒÉn b·∫£n v√† H√¨nh ·∫£nh r∆°i t∆∞∆°ng t√°c
         * T√°c gi·∫£: AI Assistant
         * Phi√™n b·∫£n: 1.0
         */

        // C·∫•u h√¨nh ch√≠nh
        const CONFIG = {
            // File paths
            TEXT_CSV: 'text/words.csv',
            IMAGES_CSV: 'images/images.csv',
            IMAGES_PATH: 'images/',
            AUDIO_CSV: 'audio/playlist.csv',
            AUDIO_PATH: 'audio/',

            // Danh s√°ch vƒÉn b·∫£n (s·∫Ω ƒë∆∞·ª£c load t·ª´ CSV)
            WORDS: [],

            // Danh s√°ch h√¨nh ·∫£nh (s·∫Ω ƒë∆∞·ª£c load t·ª´ CSV)
            IMAGES: [],
            
            // Tham s·ªë r∆°i
            FALL_SPEED: { min: 0.015, max: 0.025 },
            RESPAWN_Y: 60,
            DESPAWN_Y: -60,
            SPREAD_AREA: 100,
            
            // Tham s·ªë ƒë·ªëi t∆∞·ª£ng
            OBJECT_SIZE: { min: 2, max: 40 },
            FONT_SIZE: 64,
            
            // Tham s·ªë camera
            CAMERA_DISTANCE: 30,
            ZOOM_RANGE: { min: 5, max: 100 },
            
            // Tham s·ªë t∆∞∆°ng t√°c
            SCALE_RANGE: { min: 0.5, max: 10 },
            HOVER_SCALE: 1.2,
            SELECT_SCALE: 1.5
        };

        // Bi·∫øn to√†n c·ª•c
        let scene, camera, renderer, controls;
        let objects = [];
        let selectedObject = null;
        let raycaster, mouse;
        let isInteracting = false;
        let currentMode = 'text';
        let fallSpeedMultiplier = 5;
        let objectSpacing = 100; // Kho·∫£ng c√°ch gi·ªØa c√°c ƒë·ªëi t∆∞·ª£ng

        // Music system
        let musicGenerator = null;
        let mp3Player = null;
        let isMusicPlaying = false;
        let currentMusicType = 'ambient'; // 'ambient' or 'mp3'

        // Data loading
        let dataLoaded = false;

        // UI state - m·∫∑c ƒë·ªãnh ·∫©n t·∫•t c·∫£
        let controlsVisible = false;
        let infoVisible = false;

        // Auto-play control
        let autoPlayAttempted = false;
        let userMadeChoice = false;

        // Settings storage key
        const SETTINGS_KEY = 'rain_text_3d_settings';

        /**
         * Reset auto-play state ƒë·ªÉ c√≥ th·ªÉ th·ª≠ l·∫°i
         */
        function resetAutoPlayState() {
            autoPlayAttempted = false;
            userMadeChoice = false;
            console.log('üîÑ Auto-play state reset');
        }

        // FPS tracking
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;

        // Kh·ªüi t·∫°o ·ª©ng d·ª•ng khi DOM v√† libraries ƒë√£ s·∫µn s√†ng
        async function startApp() {
            console.log('üöÄ Starting application...');

            // ƒê·ª£i DOM s·∫µn s√†ng
            if (document.readyState === 'loading') {
                await new Promise(resolve => {
                    document.addEventListener('DOMContentLoaded', resolve);
                });
            }

            // ƒê·ª£i libraries load xong
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds max

            while (attempts < maxAttempts) {
                if (window.librariesLoaded && window.librariesLoaded.threejs) {
                    console.log('üìö Libraries ready, initializing...');
                    init();
                    return;
                }

                console.log(`‚è≥ Waiting for libraries... (${attempts + 1}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }

            // Timeout - show error
            console.error('‚ùå Timeout waiting for libraries');
            document.getElementById('loading').innerHTML = `
                <h3>‚ùå Timeout</h3>
                <p>Th∆∞ vi·ªán t·∫£i qu√° l√¢u. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet.</p>
                <button onclick="location.reload()" style="margin-top: 10px; padding: 10px; background: #00ffff; border: none; border-radius: 5px; cursor: pointer;">üîÑ Th·ª≠ l·∫°i</button>
            `;
        }

        // B·∫Øt ƒë·∫ßu ·ª©ng d·ª•ng
        startApp();

        /**
         * Ki·ªÉm tra h·ªó tr·ª£ WebGL
         */
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                return !!gl;
            } catch (e) {
                return false;
            }
        }

        /**
         * L∆∞u settings v√†o localStorage
         */
        function saveSettings() {
            const settings = {
                mode: currentMode,
                objectCount: parseInt(document.getElementById('object-count').value),
                fallSpeed: fallSpeedMultiplier,
                objectSpacing: objectSpacing,
                musicType: currentMusicType,
                musicVolume: parseFloat(document.getElementById('music-volume').value),
                playMode: document.getElementById('play-mode').value,
                selectedTrack: document.getElementById('track-select').value,
                defaultTrack: document.getElementById('default-track').value,
                autoPlayEnabled: document.getElementById('auto-play-enabled').checked,
                timestamp: Date.now()
            };

            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
                console.log('üíæ Settings saved:', settings);
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to save settings:', error);
            }
        }

        /**
         * Load settings t·ª´ localStorage
         */
        function loadSettings() {
            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (!saved) {
                    console.log('üìÇ No saved settings found');
                    return;
                }

                const settings = JSON.parse(saved);
                console.log('üìÇ Loading saved settings:', settings);

                // Apply settings to UI
                if (settings.mode) {
                    currentMode = settings.mode;
                    document.getElementById('mode-select').value = settings.mode;
                }

                if (settings.objectCount) {
                    document.getElementById('object-count').value = settings.objectCount;
                    document.getElementById('count-value').textContent = settings.objectCount;
                }

                if (settings.fallSpeed) {
                    fallSpeedMultiplier = settings.fallSpeed;
                    document.getElementById('fall-speed').value = settings.fallSpeed;
                    document.getElementById('speed-value').textContent = settings.fallSpeed;
                }

                if (settings.objectSpacing) {
                    objectSpacing = settings.objectSpacing;
                    CONFIG.SPREAD_AREA = settings.objectSpacing;
                    document.getElementById('object-spacing').value = settings.objectSpacing;
                    document.getElementById('spacing-value').textContent = settings.objectSpacing;
                }

                if (settings.musicType) {
                    currentMusicType = settings.musicType;
                    document.getElementById('music-type').value = settings.musicType;
                }

                if (settings.musicVolume !== undefined) {
                    document.getElementById('music-volume').value = settings.musicVolume;
                    document.getElementById('volume-value').textContent = Math.round(settings.musicVolume * 100) + '%';
                }

                if (settings.playMode) {
                    document.getElementById('play-mode').value = settings.playMode;
                }

                if (settings.selectedTrack !== undefined) {
                    document.getElementById('track-select').value = settings.selectedTrack;
                }

                if (settings.defaultTrack !== undefined) {
                    document.getElementById('default-track').value = settings.defaultTrack;
                }

                if (settings.autoPlayEnabled !== undefined) {
                    document.getElementById('auto-play-enabled').checked = settings.autoPlayEnabled;
                }

                console.log('‚úÖ Settings loaded successfully');
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load settings:', error);
            }
        }

        /**
         * Kh·ªüi t·∫°o c·∫£nh 3D v√† b·∫Øt ƒë·∫ßu animation
         */
        async function init() {
            console.log('üé¨ Initializing 3D scene...');

            // Ki·ªÉm tra WebGL tr∆∞·ªõc
            if (!checkWebGLSupport()) {
                console.error('‚ùå WebGL kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£');
                showWebGLError();
                return;
            }

            // Ki·ªÉm tra Three.js ƒë√£ load ch∆∞a
            if (typeof THREE === 'undefined') {
                console.error('‚ùå Three.js ch∆∞a ƒë∆∞·ª£c t·∫£i');
                document.getElementById('loading').innerHTML = `
                    <h3>‚ùå L·ªói kh·ªüi t·∫°o</h3>
                    <p>Three.js ch∆∞a ƒë∆∞·ª£c t·∫£i. ƒêang th·ª≠ l·∫°i...</p>
                `;
                setTimeout(init, 500); // Th·ª≠ l·∫°i sau 500ms
                return;
            }

            // Log Three.js version
            console.log(`üì¶ Three.js version: ${THREE.REVISION}`);

            try {
                setupScene();
                setupLighting();
                setupBackground();
                setupControls();
                setupEventListeners();
                loadSettings(); // Load saved settings
                await loadDataFiles();
                await initMusicSystem();
                createInitialObjects();
                hideLoading();
                animate();
                console.log('‚úÖ Kh·ªüi t·∫°o th√†nh c√¥ng!');
            } catch (error) {
                console.error('‚ùå L·ªói kh·ªüi t·∫°o c·∫£nh 3D:', error);
                console.error('Error details:', error);
                showWebGLError();
            }
        }

        /**
         * Thi·∫øt l·∫≠p scene, camera v√† renderer
         */
        function setupScene() {
            // T·∫°o scene
            scene = new THREE.Scene();

            // T·∫°o camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            camera.position.set(0, 0, CONFIG.CAMERA_DISTANCE);

            // T·∫°o renderer v·ªõi error handling
            const canvas = document.getElementById('canvas');
            try {
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
            } catch (error) {
                console.error('‚ùå Kh√¥ng th·ªÉ t·∫°o WebGL renderer:', error);
                throw new Error('WebGL kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a');
            }

            // Ki·ªÉm tra WebGL context
            const gl = renderer.getContext();
            if (!gl) {
                throw new Error('Kh√¥ng th·ªÉ l·∫•y WebGL context');
            }

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // T·∫Øt shadow n·∫øu kh√¥ng h·ªó tr·ª£ ƒë·ªÉ tƒÉng t∆∞∆°ng th√≠ch
            try {
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            } catch (error) {
                console.warn('‚ö†Ô∏è Shadow mapping kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£, t·∫Øt shadows');
                renderer.shadowMap.enabled = false;
            }

            // T·∫°o raycaster cho t∆∞∆°ng t√°c
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        /**
         * Thi·∫øt l·∫≠p √°nh s√°ng cho scene
         */
        function setupLighting() {
            // √Ånh s√°ng m√¥i tr∆∞·ªùng
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // √Ånh s√°ng ƒë·ªãnh h∆∞·ªõng
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // √Ånh s√°ng ƒëi·ªÉm ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng
            const pointLight = new THREE.PointLight(0x00ffff, 0.5, 100);
            pointLight.position.set(0, 20, 10);
            scene.add(pointLight);
        }

        /**
         * T·∫°o background kh√¥ng gian v·ªõi c√°c v√¨ sao l·∫•p l√°nh
         */
        function setupBackground() {
            // T·∫°o starfield v·ªõi nhi·ªÅu k√≠ch th∆∞·ªõc kh√°c nhau
            const starsGeometry = new THREE.BufferGeometry();
            const starsVertices = [];
            const starsSizes = [];
            const starsColors = [];

            for (let i = 0; i < 20000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);

                // K√≠ch th∆∞·ªõc ng·∫´u nhi√™n t·ª´ 2-8
                starsSizes.push(2 + Math.random() * 6);

                // M√†u s·∫Øc ng·∫´u nhi√™n (tr·∫Øng, xanh nh·∫°t, v√†ng nh·∫°t)
                const colorVariant = Math.random();
                if (colorVariant < 0.7) {
                    starsColors.push(1, 1, 1); // Tr·∫Øng
                } else if (colorVariant < 0.85) {
                    starsColors.push(0.8, 0.9, 1); // Xanh nh·∫°t
                } else {
                    starsColors.push(1, 1, 0.8); // V√†ng nh·∫°t
                }
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            starsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starsSizes, 1));
            starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starsColors, 3));

            // Shader material cho hi·ªáu ·ª©ng l·∫•p l√°nh
            const starsMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vSize;
                    uniform float time;

                    void main() {
                        vColor = color;
                        vSize = size;

                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

                        // Hi·ªáu ·ª©ng l·∫•p l√°nh
                        float twinkle = sin(time * 2.0 + position.x * 0.01 + position.y * 0.01) * 0.5 + 0.5;
                        gl_PointSize = size * (0.5 + twinkle * 0.5);

                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    uniform float time;

                    void main() {
                        float distance = length(gl_PointCoord - vec2(0.5));
                        if (distance > 0.5) discard;

                        // Hi·ªáu ·ª©ng glow
                        float alpha = 1.0 - distance * 2.0;
                        alpha = pow(alpha, 2.0);

                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);

            // L∆∞u reference ƒë·ªÉ animate
            scene.userData.starField = starField;
            scene.userData.starsMaterial = starsMaterial;

            // T·∫°o nebula background
            const nebulaGeometry = new THREE.SphereGeometry(1000, 32, 32);
            const nebulaMaterial = new THREE.MeshBasicMaterial({
                color: 0x000033,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);
        }

        /**
         * Thi·∫øt l·∫≠p ƒëi·ªÅu khi·ªÉn camera
         */
        function setupControls() {
            console.log('üéÆ Setting up camera controls...');
            console.log('üîç THREE.OrbitControls available:', typeof THREE.OrbitControls !== 'undefined');
            console.log('üîç THREE.TOUCH available:', typeof THREE.TOUCH !== 'undefined');

            // Ki·ªÉm tra OrbitControls c√≥ s·∫µn kh√¥ng
            if (typeof THREE.OrbitControls === 'undefined') {
                console.warn('‚ö†Ô∏è OrbitControls kh√¥ng c√≥ s·∫µn, s·ª≠ d·ª•ng ƒëi·ªÅu khi·ªÉn c∆° b·∫£n');
                setupBasicControls();
                return;
            }

            try {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = CONFIG.ZOOM_RANGE.min;
                controls.maxDistance = CONFIG.ZOOM_RANGE.max;
                controls.enablePan = false;
                controls.autoRotate = false;
                controls.autoRotateSpeed = 0.5;

                // C·∫£i thi·ªán touch controls cho mobile
                if (typeof THREE.TOUCH !== 'undefined') {
                    controls.touches = {
                        ONE: THREE.TOUCH.ROTATE,
                        TWO: THREE.TOUCH.DOLLY_PAN
                    };
                    console.log('‚úÖ Touch controls configured');
                } else {
                    console.warn('‚ö†Ô∏è THREE.TOUCH not available');
                }

                // TƒÉng sensitivity cho touch
                controls.rotateSpeed = 1.5; // Increased for better mobile response
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;

                // Touch-specific settings
                controls.enableKeys = false; // T·∫Øt keyboard controls tr√™n mobile
                controls.screenSpacePanning = false;

                console.log('‚úÖ OrbitControls initialized with enhanced touch support');
            } catch (error) {
                console.warn('‚ö†Ô∏è L·ªói kh·ªüi t·∫°o OrbitControls:', error);
                setupBasicControls();
            }
        }

        /**
         * Thi·∫øt l·∫≠p ƒëi·ªÅu khi·ªÉn camera c∆° b·∫£n (fallback)
         */
        function setupBasicControls() {
            let isMouseDown = false;
            let isTouching = false;
            let touchStartDistance = 0;
            let mouseX = 0, mouseY = 0;
            let touchX = 0, touchY = 0;
            let cameraDistance = CONFIG.CAMERA_DISTANCE;

            console.log('üì± Setting up basic controls with touch support');

            // Mouse events
            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
                event.preventDefault();
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                rotateCamera(deltaX, deltaY);

                mouseX = event.clientX;
                mouseY = event.clientY;
                event.preventDefault();
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault();
                zoomCamera(event.deltaY * 0.01);
            });

            // Touch events for mobile
            renderer.domElement.addEventListener('touchstart', (event) => {
                event.preventDefault();

                if (event.touches.length === 1) {
                    // Single touch - rotation
                    isTouching = true;
                    touchX = event.touches[0].clientX;
                    touchY = event.touches[0].clientY;
                    console.log('üëÜ Single touch start for rotation');
                } else if (event.touches.length === 2) {
                    // Two touches - zoom
                    isTouching = false; // Disable rotation
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    touchStartDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    console.log('‚úåÔ∏è Two touch start for zoom');
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchmove', (event) => {
                event.preventDefault();

                if (event.touches.length === 1 && isTouching) {
                    // Single touch rotation
                    const deltaX = event.touches[0].clientX - touchX;
                    const deltaY = event.touches[0].clientY - touchY;

                    rotateCamera(deltaX * 1.5, deltaY * 1.5); // Increased sensitivity for touch

                    touchX = event.touches[0].clientX;
                    touchY = event.touches[0].clientY;
                } else if (event.touches.length === 2) {
                    // Two touch zoom
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const currentDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );

                    const deltaDistance = currentDistance - touchStartDistance;
                    zoomCamera(-deltaDistance * 0.01); // Negative for natural pinch behavior

                    touchStartDistance = currentDistance;
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchend', (event) => {
                event.preventDefault();

                if (event.touches.length === 0) {
                    isTouching = false;
                    console.log('üñêÔ∏è Touch ended');
                } else if (event.touches.length === 1) {
                    // Back to single touch
                    isTouching = true;
                    touchX = event.touches[0].clientX;
                    touchY = event.touches[0].clientY;
                }
            }, { passive: false });

            // Helper functions
            function rotateCamera(deltaX, deltaY) {
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
            }

            function zoomCamera(delta) {
                cameraDistance += delta;
                cameraDistance = Math.max(CONFIG.ZOOM_RANGE.min, Math.min(CONFIG.ZOOM_RANGE.max, cameraDistance));

                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(cameraDistance));
            }

            // T·∫°o object gi·∫£ ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi code kh√°c
            controls = {
                update: () => {},
                enableDamping: false
            };

            console.log('‚úÖ Basic controls with touch support initialized');
        }

        /**
         * Thi·∫øt l·∫≠p c√°c event listener
         */
        function setupEventListeners() {
            // Mouse events
            renderer.domElement.addEventListener('click', onMouseClick, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('wheel', onMouseWheel, false);

            // Touch events
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            // Window resize
            window.addEventListener('resize', onWindowResize, false);

            // UI controls
            document.getElementById('mode-select').addEventListener('change', onModeChange);
            document.getElementById('object-count').addEventListener('input', onObjectCountChange);
            document.getElementById('fall-speed').addEventListener('input', onFallSpeedChange);
            document.getElementById('object-spacing').addEventListener('input', onObjectSpacingChange);
            document.getElementById('add-objects').addEventListener('click', addObjects);
            document.getElementById('clear-objects').addEventListener('click', clearAllObjects);
            document.getElementById('reload-data').addEventListener('click', reloadData);
            document.getElementById('test-mp3-ui').addEventListener('click', toggleMP3Settings);
            document.getElementById('default-track').addEventListener('change', onDefaultTrackChange);
            document.getElementById('auto-play-enabled').addEventListener('change', onAutoPlayToggle);
            document.getElementById('start-experience').addEventListener('click', startExperience);
            document.getElementById('toggle-music').addEventListener('click', toggleMusic);
            document.getElementById('prev-track').addEventListener('click', prevTrack);
            document.getElementById('next-track').addEventListener('click', nextTrack);
            document.getElementById('play-mode').addEventListener('change', onPlayModeChange);
            document.getElementById('track-select').addEventListener('change', onTrackSelect);
            document.getElementById('music-type').addEventListener('change', onMusicTypeChange);
            document.getElementById('music-volume').addEventListener('input', onVolumeChange);

            // Main settings button
            document.getElementById('main-settings').addEventListener('click', showSettings);



            // Toggle buttons
            document.getElementById('toggle-controls').addEventListener('click', toggleControls);
            document.getElementById('toggle-info').addEventListener('click', toggleInfo);

            // Keyboard shortcuts
            document.addEventListener('keydown', onKeyDown);
        }

        /**
         * Load data t·ª´ CSV files
         */
        async function loadDataFiles() {
            updateDataStatus('ƒêang t·∫£i d·ªØ li·ªáu...');

            try {
                // Load text data
                const textData = await loadCSV(CONFIG.TEXT_CSV);
                CONFIG.WORDS = textData.map(row => ({
                    text: row.text,
                    category: row.category || 'default',
                    hue: parseInt(row.color_hue) || Math.random() * 360
                }));

                // Load image data
                const imageData = await loadCSV(CONFIG.IMAGES_CSV);
                CONFIG.IMAGES = imageData.map(row => ({
                    filename: row.filename,
                    name: row.name,
                    category: row.category || 'default',
                    hue: parseInt(row.color_hue) || Math.random() * 360,
                    path: CONFIG.IMAGES_PATH + row.filename
                }));

                // Load audio playlist
                let audioCount = 0;
                try {
                    const audioData = await loadCSV(CONFIG.AUDIO_CSV);
                    CONFIG.AUDIO_PLAYLIST = audioData.map(row => ({
                        filename: row.filename,
                        name: row.name || row.filename,
                        artist: row.artist || 'Unknown',
                        duration: parseInt(row.duration) || 0,
                        category: row.category || 'music',
                        path: CONFIG.AUDIO_PATH + row.filename
                    }));
                    audioCount = CONFIG.AUDIO_PLAYLIST.length;
                } catch (error) {
                    console.warn('‚ö†Ô∏è No audio playlist found');
                    CONFIG.AUDIO_PLAYLIST = [];
                }

                dataLoaded = true;
                updateDataStatus(`‚úÖ ƒê√£ t·∫£i ${CONFIG.WORDS.length} t·ª´, ${CONFIG.IMAGES.length} h√¨nh, ${audioCount} nh·∫°c`);
                console.log('üìä Data loaded:', {
                    words: CONFIG.WORDS.length,
                    images: CONFIG.IMAGES.length,
                    audio: audioCount
                });

            } catch (error) {
                console.error('‚ùå L·ªói t·∫£i d·ªØ li·ªáu:', error);
                updateDataStatus('‚ùå L·ªói t·∫£i d·ªØ li·ªáu');

                // Fallback data
                CONFIG.WORDS = [
                    { text: 'Hello', category: 'greeting', hue: 0 },
                    { text: 'World', category: 'noun', hue: 120 },
                    { text: 'Three.js', category: 'tech', hue: 240 }
                ];
                CONFIG.IMAGES = [];
            }
        }

        /**
         * Load CSV file
         */
        async function loadCSV(filepath) {
            const response = await fetch(filepath);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const text = await response.text();
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',');

            return lines.slice(1).map(line => {
                const values = line.split(',');
                const obj = {};
                headers.forEach((header, index) => {
                    obj[header.trim()] = values[index] ? values[index].trim() : '';
                });
                return obj;
            });
        }

        /**
         * Kh·ªüi t·∫°o h·ªá th·ªëng nh·∫°c
         */
        async function initMusicSystem() {
            // Kh·ªüi t·∫°o Ambient Music Generator
            if (typeof AmbientMusicGenerator !== 'undefined') {
                musicGenerator = new AmbientMusicGenerator();
                console.log('üéπ Ambient Music Generator initialized');
            } else {
                console.warn('‚ö†Ô∏è Ambient Music Generator not available');
            }

            // Kh·ªüi t·∫°o MP3 Player
            if (typeof MP3AudioPlayer !== 'undefined') {
                mp3Player = new MP3AudioPlayer();

                console.log('üîç Checking audio playlist:', CONFIG.AUDIO_PLAYLIST);

                if (CONFIG.AUDIO_PLAYLIST && CONFIG.AUDIO_PLAYLIST.length > 0) {
                    console.log('üéµ Initializing MP3 Player with tracks:');
                    CONFIG.AUDIO_PLAYLIST.forEach((track, index) => {
                        console.log(`  Track ${index + 1}: ${track.name} (${track.path})`);
                    });

                    const success = await mp3Player.init(CONFIG.AUDIO_PLAYLIST);
                    if (success) {
                        console.log('‚úÖ MP3 Player initialized successfully with', CONFIG.AUDIO_PLAYLIST.length, 'tracks');

                        // Populate track lists first
                        populateTrackList();
                        populateDefaultTrackList();

                        // Load saved settings into MP3 UI after populating lists
                        loadSettingsIntoMP3UI();

                        // Apply saved play mode if available (redundant but safe)
                        const savedPlayMode = document.getElementById('play-mode').value;
                        if (savedPlayMode && mp3Player.setPlayMode) {
                            mp3Player.setPlayMode(savedPlayMode);
                            console.log('üîÑ Applied saved play mode:', savedPlayMode);
                        }

                        updateMusicUI();

                        // Ki·ªÉm tra auto-play setting v√† hi·ªán start overlay n·∫øu c·∫ßn
                        console.log('üéµ Current music type after settings load:', currentMusicType);
                        console.log('üéµ MP3 Player state:', {
                            hasPlayer: !!mp3Player,
                            hasAudio: !!mp3Player?.audio,
                            currentTrack: mp3Player?.getCurrentTrack(),
                            playlist: mp3Player?.getPlaylist()?.length
                        });

                        // Ki·ªÉm tra auto-play c√≥ ƒë∆∞·ª£c b·∫≠t kh√¥ng
                        const autoPlayCheckbox = document.getElementById('auto-play-enabled');
                        const autoPlayEnabled = autoPlayCheckbox ? autoPlayCheckbox.checked : false;

                        if (currentMusicType === 'mp3' && autoPlayEnabled) {
                            console.log('üéµ Auto-play enabled, showing start overlay for user interaction');
                            showStartOverlay();
                        } else {
                            console.log('üéµ Auto-play disabled or not MP3 mode, no overlay needed');
                        }
                    } else {
                        console.error('‚ùå MP3 Player initialization failed');
                        updateDataStatus('‚ùå L·ªói kh·ªüi t·∫°o MP3 player');

                        // Fallback to ambient music
                        await autoStartAmbientMusic();
                    }
                } else {
                    console.log('‚ö†Ô∏è No audio tracks found in playlist');
                    updateDataStatus('‚ö†Ô∏è Kh√¥ng c√≥ file MP3');

                    // Fallback to ambient music
                    await autoStartAmbientMusic();
                }
            } else {
                console.warn('‚ö†Ô∏è MP3 Player class not available');
                await autoStartAmbientMusic();
            }
        }

        /**
         * T·ª± ƒë·ªông b·∫Øt ƒë·∫ßu ph√°t nh·∫°c MP3
         */
        async function autoStartMusic() {
            if (!mp3Player) {
                console.warn('‚ö†Ô∏è MP3 player not available for auto-start');
                return;
            }

            console.log('üéµ autoStartMusic called, autoPlayAttempted:', autoPlayAttempted);

            if (autoPlayAttempted) {
                console.log('üéµ Auto-play already attempted, skipping');
                return;
            }

            // Ki·ªÉm tra auto-play c√≥ ƒë∆∞·ª£c b·∫≠t kh√¥ng
            const autoPlayCheckbox = document.getElementById('auto-play-enabled');
            const autoPlayEnabled = autoPlayCheckbox ? autoPlayCheckbox.checked : true; // Default true n·∫øu ch∆∞a c√≥ checkbox

            console.log('üéµ Auto-play checkbox found:', !!autoPlayCheckbox);
            console.log('üéµ Auto-play enabled:', autoPlayEnabled);

            if (!autoPlayEnabled) {
                console.log('üéµ Auto-play disabled by user setting');
                autoPlayAttempted = true;
                return;
            }

            autoPlayAttempted = true;

            try {
                console.log('üéµ Auto-starting MP3 music...');

                // ∆Øu ti√™n default track t·ª´ saved settings, sau ƒë√≥ ƒë·∫øn selected track
                let targetTrackIndex = -1;

                // L·∫•y saved settings ƒë·ªÉ check default track
                try {
                    const saved = localStorage.getItem(SETTINGS_KEY);
                    if (saved) {
                        const settings = JSON.parse(saved);
                        console.log('üéµ Checking saved settings for default track:', settings.defaultTrack);

                        // Ki·ªÉm tra default track t·ª´ settings tr∆∞·ªõc
                        if (settings.defaultTrack !== undefined && settings.defaultTrack !== '') {
                            targetTrackIndex = parseInt(settings.defaultTrack);
                            console.log('üéµ Using saved default track:', targetTrackIndex);
                        }
                        // N·∫øu kh√¥ng c√≥ default track, d√πng selected track
                        else if (settings.selectedTrack !== undefined && settings.selectedTrack !== '') {
                            targetTrackIndex = parseInt(settings.selectedTrack);
                            console.log('üéµ Using saved selected track:', targetTrackIndex);
                        }
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Failed to read saved settings for track selection:', error);
                }

                // Fallback: check UI elements
                if (targetTrackIndex === -1) {
                    const defaultTrackSelect = document.getElementById('default-track');
                    const trackSelect = document.getElementById('track-select');

                    console.log('üéµ Default track element found:', !!defaultTrackSelect);
                    console.log('üéµ Track select element found:', !!trackSelect);
                    console.log('üéµ Default track value:', defaultTrackSelect?.value);
                    console.log('üéµ Selected track value:', trackSelect?.value);

                    // Ki·ªÉm tra default track UI
                    if (defaultTrackSelect && defaultTrackSelect.value !== '') {
                        targetTrackIndex = parseInt(defaultTrackSelect.value);
                        console.log('üéµ Using UI default track:', targetTrackIndex);
                    }
                    // N·∫øu kh√¥ng c√≥ default track, d√πng selected track UI
                    else if (trackSelect && trackSelect.value !== '') {
                        targetTrackIndex = parseInt(trackSelect.value);
                        console.log('üéµ Using UI selected track:', targetTrackIndex);
                    }
                    else {
                        console.log('üéµ No default or selected track, using first track');
                    }
                }

                if (targetTrackIndex >= 0 && targetTrackIndex < mp3Player.getPlaylist().length) {
                    console.log('üéµ Loading track:', targetTrackIndex);
                    await mp3Player.selectTrack(targetTrackIndex);
                }

                console.log('üéµ Current track:', mp3Player.getCurrentTrack());

                // Delay nh·ªè ƒë·ªÉ ƒë·∫£m b·∫£o UI ƒë√£ s·∫µn s√†ng
                await new Promise(resolve => setTimeout(resolve, 500));

                console.log('üéµ Attempting to play MP3...');
                const started = await mp3Player.play();
                console.log('üéµ MP3 play result:', started);

                if (started) {
                    isMusicPlaying = true;
                    userMadeChoice = true; // User kh√¥ng c·∫ßn ch·ªçn v√¨ auto-play th√†nh c√¥ng
                    const toggleBtn = document.getElementById('toggle-music');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'üîá T·∫Øt nh·∫°c';
                    }
                    updateCurrentTrackInfo();
                    updateTrackSelectUI(); // C·∫≠p nh·∫≠t UI selection
                    const track = mp3Player.getCurrentTrack();
                    updateDataStatus(`üéµ T·ª± ƒë·ªông ph√°t: ${track?.name || 'MP3'}`);
                    console.log('‚úÖ Auto-started MP3:', track?.name);
                    console.log('üéµ Audio element state:', {
                        paused: mp3Player.audio?.paused,
                        currentTime: mp3Player.audio?.currentTime,
                        duration: mp3Player.audio?.duration,
                        volume: mp3Player.audio?.volume,
                        muted: mp3Player.audio?.muted,
                        readyState: mp3Player.audio?.readyState
                    });
                } else {
                    console.warn('‚ö†Ô∏è Auto-play blocked by browser or failed to start');
                    console.log('üéµ MP3 Player state:', {
                        hasAudio: !!mp3Player.audio,
                        currentTrack: mp3Player.getCurrentTrack(),
                        isPlaying: mp3Player.isPlaying,
                        playlist: mp3Player.getPlaylist()?.length
                    });
                }
            } catch (error) {
                console.error('‚ùå Auto-start MP3 error:', error);
            }
        }

        /**
         * T·ª± ƒë·ªông b·∫Øt ƒë·∫ßu ph√°t nh·∫°c Ambient (fallback)
         */
        async function autoStartAmbientMusic() {
            if (!musicGenerator) {
                console.warn('‚ö†Ô∏è Ambient music generator not available');
                return;
            }

            try {
                console.log('üéπ Auto-starting Ambient music...');
                currentMusicType = 'ambient';
                document.getElementById('music-type').value = 'ambient';

                const started = await musicGenerator.start();
                if (started) {
                    isMusicPlaying = true;
                    document.getElementById('toggle-music').textContent = 'üîá T·∫Øt nh·∫°c';
                    updateDataStatus('üéπ T·ª± ƒë·ªông ph√°t nh·∫°c Ambient');
                    console.log('‚úÖ Auto-started Ambient music');
                } else {
                    console.warn('‚ö†Ô∏è Failed to auto-start Ambient music');
                    updateDataStatus('‚ö†Ô∏è Kh√¥ng th·ªÉ t·ª± ƒë·ªông ph√°t nh·∫°c');
                }
            } catch (error) {
                console.error('‚ùå Auto-start Ambient error:', error);
                updateDataStatus('‚ùå L·ªói t·ª± ƒë·ªông ph√°t nh·∫°c');
            }
        }



        /**
         * B·∫Øt ƒë·∫ßu ph√°t nh·∫°c sau khi user ch·ªçn "C√≥"
         */
        async function startMusicAfterUserChoice() {
            try {
                if (currentMusicType === 'mp3' && mp3Player) {
                    const started = await mp3Player.play();
                    if (started) {
                        isMusicPlaying = true;
                        document.getElementById('toggle-music').textContent = 'üîá T·∫Øt nh·∫°c';
                        updateCurrentTrackInfo();
                        updateTrackSelectUI(); // C·∫≠p nh·∫≠t UI selection
                        const track = mp3Player.getCurrentTrack();
                        updateDataStatus(`üéµ ƒêang ph√°t: ${track?.name || 'MP3'}`);
                        console.log('üéµ MP3 music started after user choice');
                    } else {
                        // Fallback to ambient
                        await startAmbientAfterChoice();
                    }
                } else if (currentMusicType === 'ambient' && musicGenerator) {
                    await startAmbientAfterChoice();
                } else {
                    console.warn('‚ö†Ô∏è No music system available');
                    updateDataStatus('‚ùå Kh√¥ng c√≥ h·ªá th·ªëng nh·∫°c');
                }
            } catch (error) {
                console.error('‚ùå Error starting music after user choice:', error);
                updateDataStatus('‚ùå L·ªói ph√°t nh·∫°c');
            }
        }

        /**
         * B·∫Øt ƒë·∫ßu ph√°t ambient music
         */
        async function startAmbientAfterChoice() {
            if (musicGenerator) {
                const started = await musicGenerator.start();
                if (started) {
                    isMusicPlaying = true;
                    currentMusicType = 'ambient';
                    document.getElementById('music-type').value = 'ambient';
                    document.getElementById('toggle-music').textContent = 'üîá T·∫Øt nh·∫°c';
                    updateDataStatus('üéπ ƒêang ph√°t nh·∫°c Ambient');
                    console.log('üéπ Ambient music started after user choice');
                } else {
                    updateDataStatus('‚ùå Kh√¥ng th·ªÉ ph√°t nh·∫°c');
                }
            }
        }

        /**
         * C·∫≠p nh·∫≠t tr·∫°ng th√°i data
         */
        function updateDataStatus(message) {
            const statusElement = document.getElementById('data-status');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }

        /**
         * T·∫°o texture t·ª´ canvas cho vƒÉn b·∫£n (trong su·ªët, kh√¥ng background)
         */
        function createTextTexture(text, hue) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // K√≠ch th∆∞·ªõc canvas cao ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng
            canvas.width = 512;
            canvas.height = 512;

            // X√≥a canvas (trong su·ªët)
            ctx.clearRect(0, 0, 512, 512);

            // Thi·∫øt l·∫≠p font v·ªõi size ƒë·ªông d·ª±a tr√™n ƒë·ªô d√†i text
            const baseFontSize = CONFIG.FONT_SIZE;
            let fontSize = baseFontSize;

            // Gi·∫£m font size cho text d√†i
            if (text.length > 20) {
                fontSize = Math.max(32, baseFontSize - (text.length - 20) * 2);
            }

            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // T·∫°o hi·ªáu ·ª©ng glow m·∫°nh h∆°n
            ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Wrap text th√†nh nhi·ªÅu d√≤ng n·∫øu c·∫ßn
            const maxWidth = 450; // ƒê·ªÉ l·∫°i margin
            const lineHeight = fontSize * 1.2;
            const lines = wrapText(ctx, text, maxWidth);

            // T√≠nh to√°n v·ªã tr√≠ b·∫Øt ƒë·∫ßu ƒë·ªÉ center text block
            const totalHeight = lines.length * lineHeight;
            const startY = (512 - totalHeight) / 2 + lineHeight / 2;

            // V·∫Ω t·ª´ng d√≤ng
            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight);

                // V·∫Ω outline ƒë·ªÉ text n·ªïi b·∫≠t h∆°n
                ctx.strokeStyle = `hsl(${hue}, 100%, 80%)`;
                ctx.lineWidth = 3;
                ctx.strokeText(line, 256, y);

                // V·∫Ω text ch√≠nh v·ªõi m√†u s√°ng
                ctx.fillStyle = `hsl(${hue}, 100%, 90%)`;
                ctx.fillText(line, 256, y);
            });

            return canvas;
        }

        /**
         * Chia text th√†nh nhi·ªÅu d√≤ng ƒë·ªÉ fit trong width
         */
        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            for (let i = 0; i < words.length; i++) {
                const testLine = currentLine + (currentLine ? ' ' : '') + words[i];
                const metrics = ctx.measureText(testLine);

                if (metrics.width > maxWidth && currentLine !== '') {
                    // D√≤ng hi·ªán t·∫°i ƒë√£ ƒë·∫ßy, b·∫Øt ƒë·∫ßu d√≤ng m·ªõi
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }

            // Th√™m d√≤ng cu·ªëi c√πng
            if (currentLine) {
                lines.push(currentLine);
            }

            // N·∫øu kh√¥ng c√≥ d√≤ng n√†o (text r·ªóng), tr·∫£ v·ªÅ array v·ªõi 1 d√≤ng r·ªóng
            return lines.length > 0 ? lines : [''];
        }

        /**
         * T·∫°o texture h√¨nh ·∫£nh ƒë∆°n gi·∫£n (geometric shapes)
         */
        function createImageTexture(type, hue) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = 512;
            canvas.height = 512;

            // Background gradient
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.9)`);
            gradient.addColorStop(1, `hsla(${hue}, 60%, 30%, 0.3)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // V·∫Ω shape d·ª±a tr√™n type
            ctx.fillStyle = `hsl(${hue}, 90%, 80%)`;
            ctx.strokeStyle = `hsl(${hue}, 100%, 90%)`;
            ctx.lineWidth = 8;

            const centerX = 256;
            const centerY = 256;
            const size = 150;

            switch(type) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;

                case 'square':
                    ctx.fillRect(centerX - size, centerY - size, size * 2, size * 2);
                    ctx.strokeRect(centerX - size, centerY - size, size * 2, size * 2);
                    break;

                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - size);
                    ctx.lineTo(centerX - size, centerY + size);
                    ctx.lineTo(centerX + size, centerY + size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;

                case 'star':
                    drawStar(ctx, centerX, centerY, 5, size, size * 0.5);
                    ctx.fill();
                    ctx.stroke();
                    break;
            }

            return canvas;
        }

        /**
         * V·∫Ω h√¨nh sao
         */
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);

            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }

            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
        }

        /**
         * Load SVG texture b·∫±ng c√°ch convert sang canvas
         */
        function loadSVGTexture(svgPath, mesh, hue, content) {
            console.log(`üé® Loading SVG: ${svgPath}`);

            fetch(svgPath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.text();
                })
                .then(svgText => {
                    console.log(`üìÑ SVG content loaded: ${svgPath}`);

                    // T·∫°o canvas t·ª´ SVG
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 512;

                    // T·∫°o image t·ª´ SVG
                    const img = new Image();
                    const svgBlob = new Blob([svgText], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(svgBlob);

                    img.onload = function() {
                        console.log(`‚úÖ SVG image loaded: ${svgPath}`);

                        // V·∫Ω SVG l√™n canvas
                        ctx.clearRect(0, 0, 512, 512);

                        // T√≠nh to√°n ƒë·ªÉ center v√† scale SVG
                        const scale = Math.min(512 / img.width, 512 / img.height) * 0.8;
                        const x = (512 - img.width * scale) / 2;
                        const y = (512 - img.height * scale) / 2;

                        ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

                        // T·∫°o texture t·ª´ canvas
                        const texture = new THREE.CanvasTexture(canvas);
                        texture.needsUpdate = true;

                        // C·∫≠p nh·∫≠t material
                        const material = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: true,
                            alphaTest: 0.1,
                            emissive: new THREE.Color().setHSL(hue / 360, 0.6, 0.2),
                            emissiveIntensity: 0.4
                        });

                        mesh.material.dispose();
                        mesh.material = material;
                        mesh.userData.imageLoaded = true;

                        // Cleanup
                        URL.revokeObjectURL(url);
                    };

                    img.onerror = function() {
                        console.warn(`‚ö†Ô∏è Failed to load SVG image: ${svgPath}`);
                        URL.revokeObjectURL(url);
                        applyFallbackTexture(mesh, content, hue);
                    };

                    img.src = url;
                })
                .catch(error => {
                    console.warn(`‚ö†Ô∏è Failed to fetch SVG: ${svgPath}`, error);
                    applyFallbackTexture(mesh, content, hue);
                });
        }

        /**
         * Apply fallback texture khi load image th·∫•t b·∫°i
         */
        function applyFallbackTexture(mesh, content, hue) {
            console.log(`üîÑ Applying fallback texture for: ${content}`);

            const fallbackTexture = new THREE.CanvasTexture(createImageTexture(content, hue));
            fallbackTexture.needsUpdate = true;

            const fallbackMaterial = new THREE.MeshBasicMaterial({
                map: fallbackTexture,
                transparent: true,
                alphaTest: 0.1,
                emissive: new THREE.Color().setHSL(hue / 360, 0.6, 0.2),
                emissiveIntensity: 0.4
            });

            mesh.material.dispose();
            mesh.material = fallbackMaterial;
            mesh.userData.imageLoaded = true;
        }

        /**
         * T·∫°o ƒë·ªëi t∆∞·ª£ng 3D (vƒÉn b·∫£n ho·∫∑c h√¨nh ·∫£nh)
         */
        function createObject(content, type, hue, imagePath = null) {
            // T·∫°o geometry tr∆∞·ªõc
            const size = CONFIG.OBJECT_SIZE.min + Math.random() * (CONFIG.OBJECT_SIZE.max - CONFIG.OBJECT_SIZE.min);
            const geometry = new THREE.PlaneGeometry(size, size);

            // T·∫°o material t·∫°m th·ªùi v·ªõi m√†u s·∫Øc v√† loading indicator
            const tempMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(hue / 360, 0.8, 0.6),
                transparent: true,
                opacity: 0.6,
                wireframe: type === 'image' && imagePath // Wireframe cho images ƒëang load
            });

            // T·∫°o mesh v·ªõi material t·∫°m th·ªùi
            const mesh = new THREE.Mesh(geometry, tempMaterial);

            if (type === 'text') {
                // Text texture c√≥ th·ªÉ t·∫°o ngay
                const texture = new THREE.CanvasTexture(createTextTexture(content, hue));
                texture.needsUpdate = true;

                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1,
                    emissive: new THREE.Color().setHSL(hue / 360, 0.6, 0.2),
                    emissiveIntensity: 0.4
                });

                mesh.material = material;

            } else if (type === 'image' && imagePath) {
                // Load image t·ª´ file - async
                console.log(`üîÑ Loading image: ${imagePath} for content: ${content}`);

                // Th·ª≠ load b·∫±ng c√°ch kh√°c n·∫øu l√† SVG
                if (imagePath.toLowerCase().endsWith('.svg')) {
                    loadSVGTexture(imagePath, mesh, hue, content);
                } else {
                    // Load image th√¥ng th∆∞·ªùng
                    const loader = new THREE.TextureLoader();
                    loader.load(
                        imagePath,
                        function(loadedTexture) {
                            console.log(`‚úÖ Loaded image: ${imagePath}`);

                            // C·∫≠p nh·∫≠t material khi texture load xong
                            const material = new THREE.MeshBasicMaterial({
                                map: loadedTexture,
                                transparent: true,
                                alphaTest: 0.1,
                                emissive: new THREE.Color().setHSL(hue / 360, 0.6, 0.2),
                                emissiveIntensity: 0.4
                            });

                            mesh.material.dispose(); // Cleanup old material
                            mesh.material = material;
                            mesh.userData.imageLoaded = true;
                        },
                        function(progress) {
                            if (progress.total > 0) {
                                console.log(`üìä Loading progress: ${imagePath} - ${(progress.loaded / progress.total * 100).toFixed(1)}%`);
                            }
                        },
                        function(error) {
                            console.warn(`‚ö†Ô∏è Failed to load image: ${imagePath}`, error);
                            applyFallbackTexture(mesh, content, hue);
                        }
                    );
                }

            } else {
                // Fallback to generated shapes
                const texture = new THREE.CanvasTexture(createImageTexture(content, hue));
                texture.needsUpdate = true;

                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1,
                    emissive: new THREE.Color().setHSL(hue / 360, 0.6, 0.2),
                    emissiveIntensity: 0.4
                });

                mesh.material = material;
            }

            // V·ªã tr√≠ ng·∫´u nhi√™n tr√™n h√¨nh c·∫ßu (spherical distribution)
            const radius = objectSpacing * 0.8;
            const theta = Math.random() * Math.PI * 2; // G√≥c ngang (0-360¬∞)
            const phi = Math.acos(2 * Math.random() - 1); // G√≥c d·ªçc (ph√¢n b·ªë ƒë·ªÅu tr√™n c·∫ßu)

            mesh.position.x = radius * Math.sin(phi) * Math.cos(theta);
            mesh.position.y = CONFIG.RESPAWN_Y + Math.random() * 20; // M·∫∑c ƒë·ªãnh, s·∫Ω ƒë∆∞·ª£c override
            mesh.position.z = radius * Math.sin(phi) * Math.sin(theta);

            // Th√™m th√¥ng tin metadata
            mesh.userData = {
                content: content,
                type: type,
                hue: hue,
                imagePath: imagePath,
                originalScale: 1,
                fallSpeed: CONFIG.FALL_SPEED.min + Math.random() * (CONFIG.FALL_SPEED.max - CONFIG.FALL_SPEED.min),
                isPaused: false,
                isSelected: false,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                imageLoaded: type !== 'image' || !imagePath // true for text, false for images until loaded
            };

            return mesh;
        }

        /**
         * T·∫°o c√°c ƒë·ªëi t∆∞·ª£ng ban ƒë·∫ßu - ph√¢n b·ªë ƒë·ªÅu t·ª´ tr√™n xu·ªëng
         */
        function createInitialObjects() {
            const count = parseInt(document.getElementById('object-count').value);

            for (let i = 0; i < count; i++) {
                let content, type, hue, imagePath = null;

                if (currentMode === 'text') {
                    if (CONFIG.WORDS.length > 0) {
                        const wordData = CONFIG.WORDS[Math.floor(Math.random() * CONFIG.WORDS.length)];
                        content = wordData.text || wordData; // Fallback n·∫øu wordData l√† string
                        hue = wordData.hue || (i / count) * 360;
                        type = 'text';
                    } else {
                        content = 'Hello';
                        hue = (i / count) * 360;
                        type = 'text';
                    }
                } else if (currentMode === 'images') {
                    if (CONFIG.IMAGES.length > 0) {
                        const imageData = CONFIG.IMAGES[Math.floor(Math.random() * CONFIG.IMAGES.length)];
                        content = imageData.name;
                        hue = imageData.hue;
                        imagePath = imageData.path;
                        type = 'image';
                    } else {
                        const shapes = ['circle', 'square', 'triangle', 'star'];
                        content = shapes[Math.floor(Math.random() * shapes.length)];
                        hue = (i / count) * 360;
                        type = 'image';
                    }
                } else { // mixed
                    if (Math.random() > 0.5 && CONFIG.WORDS.length > 0) {
                        const wordData = CONFIG.WORDS[Math.floor(Math.random() * CONFIG.WORDS.length)];
                        content = wordData.text || wordData; // Fallback n·∫øu wordData l√† string
                        hue = wordData.hue || (i / count) * 360;
                        type = 'text';
                    } else if (CONFIG.IMAGES.length > 0) {
                        const imageData = CONFIG.IMAGES[Math.floor(Math.random() * CONFIG.IMAGES.length)];
                        content = imageData.name || imageData;
                        hue = imageData.hue || (i / count) * 360;
                        imagePath = imageData.path;
                        type = 'image';
                    } else {
                        content = 'Hello';
                        hue = (i / count) * 360;
                        type = 'text';
                    }
                }

                const obj = createObject(content, type, hue, imagePath);

                // Ph√¢n b·ªë ƒë·ªÅu t·ª´ tr√™n xu·ªëng ƒë·ªÉ kh√¥ng c√≥ kho·∫£ng tr·ªëng
                const fallDistance = CONFIG.RESPAWN_Y - CONFIG.DESPAWN_Y;
                const progress = i / count;
                obj.position.y = CONFIG.DESPAWN_Y + (fallDistance * progress) + Math.random() * 5;

                // Hi·ªáu ·ª©ng xu·∫•t hi·ªán: b·∫Øt ƒë·∫ßu t·ª´ scale 0 v√† tƒÉng d·∫ßn
                obj.scale.setScalar(0);
                obj.userData.spawnTime = Date.now() + (i * 30); // Delay m·ªói object 30ms
                obj.userData.isSpawning = true;

                scene.add(obj);
                objects.push(obj);
            }

            updateObjectCount();
            console.log(`‚úÖ T·∫°o ${count} ƒë·ªëi t∆∞·ª£ng ph√¢n b·ªë ƒë·ªÅu t·ª´ tr√™n xu·ªëng`);
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán click chu·ªôt
         */
        function onMouseClick(event) {
            event.preventDefault();

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                // B·∫•m v√†o ph·∫ßn t·ª≠ - d·ª´ng v√† cho ph√©p zoom
                selectObject(intersects[0].object);
            } else {
                // B·∫•m ra ngo√†i - tr·ªü v·ªÅ b√¨nh th∆∞·ªùng
                deselectObject();
            }
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán di chuy·ªÉn chu·ªôt
         */
        function onMouseMove(event) {
            // Kh√¥ng c·∫ßn x·ª≠ l√Ω drag ƒë·ªÉ scale n·ªØa
            // Ch·ªâ d√πng scroll wheel ƒë·ªÉ zoom
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán scroll wheel
         */
        function onMouseWheel(event) {
            event.preventDefault();

            if (selectedObject) {
                // Zoom ph·∫ßn t·ª≠ ƒë∆∞·ª£c ch·ªçn
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                const currentScale = selectedObject.scale.x;
                const newScale = THREE.MathUtils.clamp(
                    currentScale + delta,
                    CONFIG.SCALE_RANGE.min,
                    CONFIG.SCALE_RANGE.max
                );
                selectedObject.scale.setScalar(newScale);

                console.log(`üîç Zoom object: ${newScale.toFixed(2)}x`);
            }
            // N·∫øu kh√¥ng c√≥ object ƒë∆∞·ª£c ch·ªçn, ƒë·ªÉ OrbitControls x·ª≠ l√Ω zoom camera
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán touch start
         */
        function onTouchStart(event) {
            event.preventDefault();

            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(objects);

                if (intersects.length > 0) {
                    // Touch v√†o ph·∫ßn t·ª≠ - d·ª´ng v√† cho ph√©p zoom b·∫±ng pinch
                    selectObject(intersects[0].object);
                } else {
                    // Touch ra ngo√†i - tr·ªü v·ªÅ b√¨nh th∆∞·ªùng
                    deselectObject();
                }
            }
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán touch move (cho pinch zoom)
         */
        function onTouchMove(event) {
            event.preventDefault();

            // X·ª≠ l√Ω pinch zoom cho object ƒë∆∞·ª£c ch·ªçn
            if (selectedObject && event.touches.length === 2) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];

                const distance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                if (!selectedObject.userData.lastTouchDistance) {
                    selectedObject.userData.lastTouchDistance = distance;
                    return;
                }

                const delta = (distance - selectedObject.userData.lastTouchDistance) * 0.01;
                const currentScale = selectedObject.scale.x;
                const newScale = THREE.MathUtils.clamp(
                    currentScale + delta,
                    CONFIG.SCALE_RANGE.min,
                    CONFIG.SCALE_RANGE.max
                );

                selectedObject.scale.setScalar(newScale);
                selectedObject.userData.lastTouchDistance = distance;
            }
        }

        /**
         * X·ª≠ l√Ω s·ª± ki·ªán touch end
         */
        function onTouchEnd(event) {
            event.preventDefault();

            if (selectedObject) {
                selectedObject.userData.lastTouchDistance = null;
            }

            // Kh√¥ng t·ª± ƒë·ªông deselect khi touch end
            // Ch·ªâ deselect khi touch v√†o ch·ªó kh√°c
        }

        /**
         * Ch·ªçn ƒë·ªëi t∆∞·ª£ng
         */
        function selectObject(obj) {
            // B·ªè ch·ªçn ƒë·ªëi t∆∞·ª£ng c≈© n·∫øu c√≥
            if (selectedObject && selectedObject !== obj) {
                selectedObject.userData.isPaused = false;
                selectedObject.userData.isSelected = false;
                selectedObject.scale.setScalar(1);
            }

            // Ch·ªçn ƒë·ªëi t∆∞·ª£ng m·ªõi
            selectedObject = obj;
            selectedObject.userData.isPaused = true;  // D·ª´ng r∆°i
            selectedObject.userData.isSelected = true;
            selectedObject.scale.setScalar(1.2);  // Scale nh·∫π ƒë·ªÉ hi·ªÉn th·ªã ƒë∆∞·ª£c ch·ªçn

            // C·∫≠p nh·∫≠t UI
            const content = obj.userData.content;
            const type = obj.userData.type;
            document.getElementById('selected-object').textContent = `${type}: ${content}`;

            console.log(`üéØ Selected: ${content} (${type})`);
        }

        /**
         * B·ªè ch·ªçn ƒë·ªëi t∆∞·ª£ng
         */
        function deselectObject() {
            if (selectedObject) {
                selectedObject.userData.isPaused = false;  // Ti·∫øp t·ª•c r∆°i
                selectedObject.userData.isSelected = false;
                selectedObject.scale.setScalar(1);  // Tr·ªü v·ªÅ k√≠ch th∆∞·ªõc ban ƒë·∫ßu
                selectedObject.userData.lastTouchDistance = null;  // Reset touch data

                console.log(`üîÑ Deselected: ${selectedObject.userData.content}`);
                selectedObject = null;
            }

            document.getElementById('selected-object').textContent = 'Kh√¥ng c√≥';
        }

        /**
         * Toggle nh·∫°c n·ªÅn
         */
        async function toggleMusic() {
            try {
                if (currentMusicType === 'ambient') {
                    if (!musicGenerator) {
                        console.warn('‚ö†Ô∏è Ambient music not available');
                        return;
                    }

                    if (isMusicPlaying) {
                        musicGenerator.stop();
                        isMusicPlaying = false;
                        document.getElementById('toggle-music').textContent = 'üéµ B·∫≠t nh·∫°c';
                        updateDataStatus('üîá ƒê√£ t·∫Øt nh·∫°c Ambient');
                        console.log('üîá Ambient music stopped');
                    } else {
                        const started = await musicGenerator.start();
                        if (started) {
                            isMusicPlaying = true;
                            document.getElementById('toggle-music').textContent = 'üîá T·∫Øt nh·∫°c';
                            updateDataStatus('üéπ ƒêang ph√°t nh·∫°c Ambient');
                            console.log('üéµ Ambient music started');
                        }
                    }
                } else { // MP3
                    if (!mp3Player) {
                        console.warn('‚ö†Ô∏è MP3 player not available');
                        updateDataStatus('‚ùå MP3 player kh√¥ng c√≥ s·∫µn');
                        return;
                    }

                    if (!mp3Player.audio) {
                        console.warn('‚ö†Ô∏è No audio loaded in MP3 player');
                        updateDataStatus('‚ùå Kh√¥ng c√≥ file MP3 n√†o ƒë∆∞·ª£c t·∫£i');

                        // Th·ª≠ reload audio
                        if (CONFIG.AUDIO_PLAYLIST && CONFIG.AUDIO_PLAYLIST.length > 0) {
                            console.log('üîÑ Trying to reload audio...');
                            const success = await mp3Player.init(CONFIG.AUDIO_PLAYLIST);
                            if (!success) {
                                updateDataStatus('‚ùå Kh√¥ng th·ªÉ t·∫£i file MP3');
                                return;
                            }
                        } else {
                            updateDataStatus('‚ùå Kh√¥ng c√≥ file MP3 trong playlist');
                            return;
                        }
                    }

                    if (isMusicPlaying) {
                        mp3Player.pause();
                        isMusicPlaying = false;
                        document.getElementById('toggle-music').textContent = 'üéµ B·∫≠t nh·∫°c';
                        updateDataStatus('üîá ƒê√£ t·∫Øt nh·∫°c MP3');
                        console.log('üîá MP3 paused');
                    } else {
                        console.log('üéµ Attempting to play MP3...');
                        const started = await mp3Player.play();
                        if (started) {
                            isMusicPlaying = true;
                            document.getElementById('toggle-music').textContent = 'üîá T·∫Øt nh·∫°c';
                            updateCurrentTrackInfo();
                            updateDataStatus('üéµ ƒêang ph√°t nh·∫°c MP3');
                            console.log('üéµ MP3 playing successfully');
                        } else {
                            console.error('‚ùå Failed to start MP3 playback');
                            updateDataStatus('‚ùå Kh√¥ng th·ªÉ ph√°t MP3');
                        }
                    }
                }
            } catch (error) {
                console.error('‚ùå Music error:', error);
            }
        }

        /**
         * Chuy·ªÉn b√†i ti·∫øp theo (ch·ªâ cho MP3)
         */
        async function nextTrack() {
            if (currentMusicType === 'mp3' && mp3Player) {
                await mp3Player.nextTrack();
                updateCurrentTrackInfo();
                updateTrackSelectUI();
                if (isMusicPlaying) {
                    const track = mp3Player.getCurrentTrack();
                    updateDataStatus(`üéµ ƒêang ph√°t: ${track?.name || 'MP3'}`);
                }
            }
        }

        /**
         * Chuy·ªÉn b√†i tr∆∞·ªõc ƒë√≥ (ch·ªâ cho MP3)
         */
        async function prevTrack() {
            if (currentMusicType === 'mp3' && mp3Player) {
                await mp3Player.previousTrack();
                updateCurrentTrackInfo();
                updateTrackSelectUI();
                if (isMusicPlaying) {
                    const track = mp3Player.getCurrentTrack();
                    updateDataStatus(`üéµ ƒêang ph√°t: ${track?.name || 'MP3'}`);
                }
            }
        }

        /**
         * Thay ƒë·ªïi ch·∫ø ƒë·ªô ph√°t
         */
        function onPlayModeChange(event) {
            const mode = event.target.value;
            if (currentMusicType === 'mp3' && mp3Player) {
                mp3Player.setPlayMode(mode);
                updateDataStatus(`üîÑ Ch·∫ø ƒë·ªô ph√°t: ${getPlayModeText(mode)}`);
            }
            saveSettings();
        }

        /**
         * Ch·ªçn track t·ª´ dropdown
         */
        async function onTrackSelect(event) {
            const trackIndex = parseInt(event.target.value);
            if (isNaN(trackIndex) || currentMusicType !== 'mp3' || !mp3Player) return;

            await mp3Player.selectTrack(trackIndex);
            updateCurrentTrackInfo();

            if (isMusicPlaying) {
                const track = mp3Player.getCurrentTrack();
                updateDataStatus(`üéµ ƒêang ph√°t: ${track?.name || 'MP3'}`);
            }

            saveSettings();
        }

        /**
         * L·∫•y text hi·ªÉn th·ªã cho play mode
         */
        function getPlayModeText(mode) {
            switch (mode) {
                case 'sequential': return 'üîÑ Tu·∫ßn t·ª±';
                case 'loop': return 'üîÅ L·∫∑p l·∫°i';
                case 'random': return 'üîÄ Ng·∫´u nhi√™n';
                default: return mode;
            }
        }

        /**
         * C·∫≠p nh·∫≠t UI track select dropdown
         */
        function updateTrackSelectUI() {
            if (currentMusicType !== 'mp3' || !mp3Player) return;

            const trackSelect = document.getElementById('track-select');
            const currentTrack = mp3Player.getCurrentTrack();
            const playlist = mp3Player.getPlaylist();

            // T√¨m index c·ªßa track hi·ªán t·∫°i
            const currentIndex = playlist.findIndex(track =>
                track.name === currentTrack?.name && track.path === currentTrack?.path
            );

            if (currentIndex !== -1) {
                trackSelect.value = currentIndex.toString();
            }
        }

        /**
         * Thay ƒë·ªïi lo·∫°i nh·∫°c
         */
        function onMusicTypeChange(event) {
            const newType = event.target.value;

            // D·ª´ng nh·∫°c hi·ªán t·∫°i
            if (isMusicPlaying) {
                if (currentMusicType === 'ambient' && musicGenerator) {
                    musicGenerator.stop();
                } else if (currentMusicType === 'mp3' && mp3Player) {
                    mp3Player.pause();
                }
                isMusicPlaying = false;
                updateDataStatus('üîá ƒê√£ chuy·ªÉn lo·∫°i nh·∫°c');
            }

            currentMusicType = newType;

            // C·∫≠p nh·∫≠t UI ngay l·∫≠p t·ª©c
            updateMusicUI();

            document.getElementById('toggle-music').textContent = 'üéµ B·∫≠t nh·∫°c';
            console.log('üîÑ Switched to', newType, 'music');

            // Reset MP3 settings button n·∫øu c√≥
            const settingsBtn = document.getElementById('test-mp3-ui');
            if (settingsBtn) {
                settingsBtn.textContent = 'üéµ C√†i ƒë·∫∑t MP3';
                settingsBtn.style.background = '#4CAF50';
            }

            saveSettings();
        }

        /**
         * Thay ƒë·ªïi b√†i m·∫∑c ƒë·ªãnh
         */
        function onDefaultTrackChange(event) {
            const defaultTrackIndex = event.target.value;
            console.log('üéµ Default track changed to:', defaultTrackIndex);
            saveSettings();
        }

        /**
         * Toggle auto-play
         */
        function onAutoPlayToggle(event) {
            const autoPlayEnabled = event.target.checked;
            console.log('üéµ Auto-play toggled:', autoPlayEnabled);

            // Reset auto-play state ƒë·ªÉ c√≥ th·ªÉ th·ª≠ l·∫°i n·∫øu user b·∫≠t l·∫°i
            if (autoPlayEnabled) {
                resetAutoPlayState();
                console.log('üéµ Auto-play enabled, will attempt on next music start');
            }

            saveSettings();
        }

        /**
         * C·∫≠p nh·∫≠t UI theo lo·∫°i nh·∫°c
         */
        function updateMusicUI() {
            const mp3Controls = document.getElementById('mp3-controls');
            const trackInfo = document.getElementById('current-track-info');

            console.log('üéÆ updateMusicUI called:', {
                currentMusicType,
                mp3Player: !!mp3Player,
                playlist: mp3Player ? mp3Player.getPlaylist().length : 0
            });

            if (currentMusicType === 'mp3' && mp3Player && mp3Player.getPlaylist().length > 0) {
                console.log('‚úÖ Showing MP3 controls');
                mp3Controls.style.display = 'block';
                trackInfo.style.display = 'block';

                // Populate track list
                populateTrackList();

                // Update current track selection
                updateTrackSelectUI();
                updateCurrentTrackInfo();
            } else {
                console.log('‚ùå Hiding MP3 controls:', {
                    reason: currentMusicType !== 'mp3' ? 'not mp3 mode' :
                           !mp3Player ? 'no mp3 player' :
                           'no tracks in playlist'
                });
                mp3Controls.style.display = 'none';
                trackInfo.style.display = 'none';
            }
        }

        /**
         * Populate danh s√°ch b√†i h√°t v√†o dropdown
         */
        function populateTrackList() {
            console.log('üìã populateTrackList called');

            if (currentMusicType !== 'mp3' || !mp3Player) {
                console.log('‚ùå Cannot populate: not MP3 mode or no player');
                return;
            }

            const trackSelect = document.getElementById('track-select');
            const playlist = mp3Player.getPlaylist();

            console.log('üìã Track select element:', !!trackSelect);
            console.log('üìã Playlist:', playlist);

            if (!trackSelect) {
                console.error('‚ùå track-select element not found!');
                return;
            }

            // Clear existing options (except first one)
            trackSelect.innerHTML = '<option value="">-- Ch·ªçn b√†i h√°t --</option>';

            // Add tracks to dropdown
            playlist.forEach((track, index) => {
                const option = document.createElement('option');
                option.value = index.toString();
                option.textContent = track.name;
                trackSelect.appendChild(option);
                console.log(`üìã Added track ${index}: ${track.name}`);
            });

            console.log(`‚úÖ Populated track list with ${playlist.length} tracks`);
        }

        /**
         * Populate danh s√°ch b√†i h√°t v√†o default track dropdown
         */
        function populateDefaultTrackList() {
            console.log('üìã populateDefaultTrackList called');

            if (currentMusicType !== 'mp3' || !mp3Player) {
                console.log('‚ùå Cannot populate default tracks: not MP3 mode or no player');
                return;
            }

            const defaultTrackSelect = document.getElementById('default-track');
            const playlist = mp3Player.getPlaylist();

            if (!defaultTrackSelect) {
                console.error('‚ùå default-track element not found!');
                return;
            }

            if (!playlist || playlist.length === 0) {
                console.warn('‚ö†Ô∏è No playlist available for default tracks');
                return;
            }

            // Clear existing options (except first one)
            defaultTrackSelect.innerHTML = '<option value="">-- Kh√¥ng ƒë·∫∑t m·∫∑c ƒë·ªãnh --</option>';

            // Add tracks to dropdown
            playlist.forEach((track, index) => {
                const option = document.createElement('option');
                option.value = index.toString();
                option.textContent = track.name || `Track ${index + 1}`;
                defaultTrackSelect.appendChild(option);
                console.log(`üìã Added default track ${index}: ${track.name}`);
            });

            // Load saved default track value s·∫Ω ƒë∆∞·ª£c handle b·ªüi loadSettingsIntoMP3UI
            console.log('üìã Default track list populated, will load saved value later');

            console.log(`‚úÖ Populated default track list with ${playlist.length} tracks`);
        }

        /**
         * C·∫≠p nh·∫≠t th√¥ng tin b√†i h√°t hi·ªán t·∫°i
         */
        function updateCurrentTrackInfo() {
            if (currentMusicType === 'mp3' && mp3Player) {
                const track = mp3Player.getCurrentTrack();
                const trackElement = document.getElementById('current-track');

                if (track) {
                    trackElement.textContent = `${track.name} - ${track.artist}`;
                } else {
                    trackElement.textContent = 'Kh√¥ng c√≥';
                }
            }
        }

        /**
         * Thay ƒë·ªïi √¢m l∆∞·ª£ng nh·∫°c
         */
        function onVolumeChange(event) {
            const volume = parseFloat(event.target.value);
            document.getElementById('volume-value').textContent = Math.round(volume * 100) + '%';

            if (currentMusicType === 'ambient' && musicGenerator) {
                musicGenerator.setVolume(volume);
            } else if (currentMusicType === 'mp3' && mp3Player) {
                mp3Player.setVolume(volume);
            }

            saveSettings();
        }

        /**
         * Load saved settings v√†o MP3 UI khi m·ªü settings panel
         */
        function loadSettingsIntoMP3UI() {
            console.log('üéµ Loading settings into MP3 UI...');

            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (!saved) {
                    console.log('üìÇ No saved settings found for MP3 UI');
                    return;
                }

                const settings = JSON.parse(saved);
                console.log('üìÇ Loading MP3 settings:', settings);

                // Load play mode
                if (settings.playMode) {
                    const playModeSelect = document.getElementById('play-mode');
                    if (playModeSelect) {
                        playModeSelect.value = settings.playMode;
                        console.log('üîÑ Set play mode to:', settings.playMode);

                        // Apply to MP3 player
                        if (mp3Player && mp3Player.setPlayMode) {
                            mp3Player.setPlayMode(settings.playMode);
                        }
                    }
                }

                // Load selected track
                if (settings.selectedTrack !== undefined) {
                    const trackSelect = document.getElementById('track-select');
                    if (trackSelect) {
                        trackSelect.value = settings.selectedTrack;
                        console.log('üéµ Set selected track to:', settings.selectedTrack);
                    }
                }

                // Load default track
                if (settings.defaultTrack !== undefined) {
                    const defaultTrackSelect = document.getElementById('default-track');
                    if (defaultTrackSelect) {
                        defaultTrackSelect.value = settings.defaultTrack;
                        console.log('üéµ Set default track to:', settings.defaultTrack);
                    }
                }

                // Load auto-play setting
                if (settings.autoPlayEnabled !== undefined) {
                    const autoPlayCheckbox = document.getElementById('auto-play-enabled');
                    if (autoPlayCheckbox) {
                        autoPlayCheckbox.checked = settings.autoPlayEnabled;
                        console.log('üéµ Set auto-play to:', settings.autoPlayEnabled);
                    }
                }

                console.log('‚úÖ MP3 UI settings loaded successfully');
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load MP3 UI settings:', error);
            }
        }



        /**
         * Hi·ªÉn th·ªã start overlay ƒë·ªÉ user interaction
         */
        function showStartOverlay() {
            console.log('üéµ Showing start overlay for user interaction');
            const overlay = document.getElementById('start-overlay');
            const loading = document.getElementById('loading');

            if (overlay && loading) {
                loading.style.display = 'none';
                overlay.style.display = 'flex';
            }
        }

        /**
         * B·∫Øt ƒë·∫ßu tr·∫£i nghi·ªám sau user interaction
         */
        async function startExperience() {
            console.log('üöÄ User clicked start experience - beginning auto-play');

            const overlay = document.getElementById('start-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }

            // Reset auto-play state
            resetAutoPlayState();

            // B√¢y gi·ªù c√≥ user interaction, c√≥ th·ªÉ auto-play
            if (currentMusicType === 'mp3' && mp3Player) {
                console.log('üéµ Starting MP3 with user interaction...');
                await autoStartMusic();
            } else if (currentMusicType === 'ambient' && musicGenerator) {
                console.log('üéµ Starting ambient music with user interaction...');
                await autoStartAmbientMusic();
            }
        }

        /**
         * ƒê·ªìng b·ªô tr·∫°ng th√°i MP3 settings button v·ªõi panel hi·ªán t·∫°i
         */
        function syncMP3SettingsState() {
            const mp3Controls = document.getElementById('mp3-controls');
            const trackInfo = document.getElementById('current-track-info');
            const settingsBtn = document.getElementById('test-mp3-ui');

            if (!mp3Controls || !trackInfo || !settingsBtn) {
                console.log('üéµ MP3 elements not found for sync');
                return;
            }

            // Ki·ªÉm tra tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa MP3 controls
            const mp3ControlsVisible = mp3Controls.style.display === 'block';
            const trackInfoVisible = trackInfo.style.display === 'block';
            const isMP3SettingsVisible = mp3ControlsVisible || trackInfoVisible;

            console.log('üéµ Syncing MP3 settings state:', {
                mp3ControlsVisible,
                trackInfoVisible,
                isMP3SettingsVisible
            });

            // C·∫≠p nh·∫≠t button text v√† style theo tr·∫°ng th√°i th·ª±c t·∫ø
            if (isMP3SettingsVisible) {
                settingsBtn.textContent = 'üîá ·∫®n c√†i ƒë·∫∑t';
                settingsBtn.style.background = '#f44336';
                console.log('üéµ MP3 settings button synced to "open" state');
            } else {
                settingsBtn.textContent = 'üéµ C√†i ƒë·∫∑t MP3';
                settingsBtn.style.background = '#4CAF50';
                console.log('üéµ MP3 settings button synced to "closed" state');
            }
        }

        /**
         * Reload data t·ª´ files
         */
        async function reloadData() {
            updateDataStatus('ƒêang t·∫£i l·∫°i...');
            await loadDataFiles();

            // Clear existing objects and recreate
            clearAllObjects();
            createInitialObjects();
        }

        /**
         * Toggle MP3 Settings Panel
         */
        function toggleMP3Settings() {
            console.log('üéµ Toggling MP3 Settings...');

            const mp3Controls = document.getElementById('mp3-controls');
            const trackInfo = document.getElementById('current-track-info');
            const settingsBtn = document.getElementById('test-mp3-ui');

            console.log('üéµ MP3 Controls element:', mp3Controls);
            console.log('üéµ Track Info element:', trackInfo);
            console.log('üéµ Current display style:', mp3Controls?.style.display);

            // Check current state - consider both 'block' and empty/undefined as visible states
            const currentDisplay = mp3Controls ? mp3Controls.style.display : 'none';
            const isCurrentlyVisible = currentDisplay === 'block';

            console.log('üéµ Is currently visible:', isCurrentlyVisible);

            if (mp3Controls && trackInfo) {
                if (isCurrentlyVisible) {
                    // Hide MP3 settings
                    mp3Controls.style.display = 'none';
                    trackInfo.style.display = 'none';
                    settingsBtn.textContent = 'üéµ C√†i ƒë·∫∑t MP3';
                    settingsBtn.style.background = '#4CAF50';
                    console.log('‚ùå Hidden MP3 settings');
                } else {
                    // Show MP3 settings
                    mp3Controls.style.display = 'block';
                    trackInfo.style.display = 'block';
                    settingsBtn.textContent = 'üîá ·∫®n c√†i ƒë·∫∑t';
                    settingsBtn.style.background = '#f44336';

                    // Force set MP3 mode
                    currentMusicType = 'mp3';
                    document.getElementById('music-type').value = 'mp3';

                    // Populate track lists
                    if (mp3Player) {
                        populateTrackList();
                        populateDefaultTrackList();

                        // Load saved settings into UI
                        loadSettingsIntoMP3UI();
                    } else {
                        console.log('‚ùå No MP3 player available');
                    }

                    console.log('‚úÖ Shown MP3 settings');
                }
            } else {
                console.error('‚ùå MP3 Controls or Track Info elements not found!');
            }

            console.log('üéµ MP3 Settings state:', {
                currentMusicType,
                mp3Player: !!mp3Player,
                playlist: mp3Player ? mp3Player.getPlaylist() : null,
                visible: !isCurrentlyVisible
            });
        }

        /**
         * Hi·ªán settings (controls + info)
         */
        function showSettings() {
            const controlsPanel = document.getElementById('controls');
            const infoPanel = document.getElementById('info');
            const mainBtn = document.getElementById('main-settings');

            // Hi·ªán c·∫£ controls v√† info
            controlsVisible = true;
            infoVisible = true;

            controlsPanel.classList.add('visible');
            infoPanel.classList.add('visible');

            // ·∫®n main settings button
            mainBtn.style.display = 'none';

            // Ki·ªÉm tra v√† ƒë·ªìng b·ªô tr·∫°ng th√°i MP3 settings n·∫øu ƒëang hi·ªán
            syncMP3SettingsState();

            console.log('üì± Settings panels shown');
        }

        /**
         * Toggle hi·ªÉn th·ªã controls panel
         */
        function toggleControls() {
            const controlsPanel = document.getElementById('controls');
            const infoPanel = document.getElementById('info');
            const mainBtn = document.getElementById('main-settings');

            controlsVisible = !controlsVisible;

            if (controlsVisible) {
                controlsPanel.classList.add('visible');
                // ƒê·ªìng b·ªô MP3 settings state khi hi·ªán controls
                syncMP3SettingsState();
                console.log('üì± Controls panel shown');
            } else {
                controlsPanel.classList.remove('visible');

                // Khi ·∫©n controls, c≈©ng ·∫©n info panel
                if (infoVisible) {
                    infoPanel.classList.remove('visible');
                    infoVisible = false;
                    console.log('üì± Info panel also hidden');
                }

                // Hi·ªán main settings button khi ·∫©n h·∫øt
                mainBtn.style.display = 'block';
                console.log('üì± Controls panel hidden');
            }
        }

        /**
         * Toggle hi·ªÉn th·ªã info panel
         */
        function toggleInfo() {
            const infoPanel = document.getElementById('info');
            const toggleBtn = document.getElementById('toggle-info');
            const mainBtn = document.getElementById('main-settings');

            infoVisible = !infoVisible;

            if (infoVisible) {
                infoPanel.classList.add('visible');
                toggleBtn.textContent = '‚ùì';
                toggleBtn.title = '·∫®n h∆∞·ªõng d·∫´n';
                // ƒê·ªìng b·ªô MP3 settings state khi hi·ªán info
                syncMP3SettingsState();
                console.log('üì± Info panel shown');
            } else {
                infoPanel.classList.remove('visible');
                toggleBtn.textContent = '‚ùå';
                toggleBtn.title = 'Hi·ªán h∆∞·ªõng d·∫´n';

                // N·∫øu c·∫£ controls v√† info ƒë·ªÅu ·∫©n, hi·ªán main settings button
                if (!controlsVisible) {
                    mainBtn.style.display = 'block';
                }
                console.log('üì± Info panel hidden');
            }
        }

        /**
         * X·ª≠ l√Ω keyboard shortcuts
         */
        function onKeyDown(event) {
            // Kh√¥ng x·ª≠ l√Ω n·∫øu ƒëang focus v√†o input
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT') {
                return;
            }

            switch(event.key.toLowerCase()) {
                case 's':
                    // S ƒë·ªÉ m·ªü settings
                    if (!controlsVisible && !infoVisible) {
                        showSettings();
                    }
                    break;
                case 'c':
                    toggleControls();
                    break;
                case 'h':
                case '?':
                    toggleInfo();
                    break;
                case ' ':
                    event.preventDefault();
                    toggleMusic();
                    break;
                case 'r':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        reloadData();
                    }
                    break;
                case 'escape':
                    deselectObject();
                    break;
            }
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi ch·∫ø ƒë·ªô hi·ªÉn th·ªã
         */
        function onModeChange(event) {
            currentMode = event.target.value;
            clearAllObjects();
            createInitialObjects();
            saveSettings();
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi s·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng
         */
        function onObjectCountChange(event) {
            const value = event.target.value;
            document.getElementById('count-value').textContent = value;
            saveSettings();
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi t·ªëc ƒë·ªô r∆°i
         */
        function onFallSpeedChange(event) {
            fallSpeedMultiplier = parseInt(event.target.value);
            document.getElementById('speed-value').textContent = fallSpeedMultiplier;
            saveSettings();
        }

        /**
         * X·ª≠ l√Ω thay ƒë·ªïi kho·∫£ng c√°ch ƒë·ªëi t∆∞·ª£ng
         */
        function onObjectSpacingChange(event) {
            objectSpacing = parseInt(event.target.value);
            document.getElementById('spacing-value').textContent = objectSpacing;

            // C·∫≠p nh·∫≠t SPREAD_AREA trong CONFIG
            CONFIG.SPREAD_AREA = objectSpacing;

            // √Åp d·ª•ng spacing m·ªõi cho t·∫•t c·∫£ objects hi·ªán t·∫°i
            redistributeObjects();

            console.log(`üìè Object spacing changed to: ${objectSpacing}`);
            saveSettings();
        }

        /**
         * Ph√¢n b·ªë l·∫°i t·∫•t c·∫£ objects v·ªõi spacing m·ªõi
         */
        function redistributeObjects() {
            const radius = objectSpacing * 0.8;

            objects.forEach((obj) => {
                // Gi·ªØ nguy√™n Y position, ch·ªâ thay ƒë·ªïi X v√† Z
                const currentY = obj.position.y;

                // T·∫°o v·ªã tr√≠ m·ªõi tr√™n h√¨nh c·∫ßu
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                obj.position.x = radius * Math.sin(phi) * Math.cos(theta);
                obj.position.y = currentY; // Gi·ªØ nguy√™n Y
                obj.position.z = radius * Math.sin(phi) * Math.sin(theta);
            });

            console.log(`üîÑ Redistributed ${objects.length} objects with spacing: ${objectSpacing}`);
        }

        /**
         * Th√™m ƒë·ªëi t∆∞·ª£ng m·ªõi v·ªõi ph√¢n b·ªë ng·∫´u nhi√™n
         */
        function addObjects() {
            const addCount = Math.min(20, parseInt(document.getElementById('object-count').value));

            for (let i = 0; i < addCount; i++) {
                let content, type, hue, imagePath = null;

                if (currentMode === 'text') {
                    if (CONFIG.WORDS.length > 0) {
                        const wordData = CONFIG.WORDS[Math.floor(Math.random() * CONFIG.WORDS.length)];
                        content = wordData.text || wordData; // Fallback n·∫øu wordData l√† string
                        hue = wordData.hue || Math.random() * 360;
                        type = 'text';
                    } else {
                        content = 'Hello';
                        hue = Math.random() * 360;
                        type = 'text';
                    }
                } else if (currentMode === 'images') {
                    if (CONFIG.IMAGES.length > 0) {
                        const imageData = CONFIG.IMAGES[Math.floor(Math.random() * CONFIG.IMAGES.length)];
                        content = imageData.name || imageData;
                        hue = imageData.hue || Math.random() * 360;
                        imagePath = imageData.path;
                        type = 'image';
                        console.log(`‚ûï Adding image: ${content} from ${imagePath}`);
                    } else {
                        const shapes = ['circle', 'square', 'triangle', 'star'];
                        content = shapes[Math.floor(Math.random() * shapes.length)];
                        hue = Math.random() * 360;
                        type = 'image';
                    }
                } else {
                    if (Math.random() > 0.5 && CONFIG.WORDS.length > 0) {
                        const wordData = CONFIG.WORDS[Math.floor(Math.random() * CONFIG.WORDS.length)];
                        content = wordData.text || wordData;
                        hue = wordData.hue || Math.random() * 360;
                        type = 'text';
                    } else if (CONFIG.IMAGES.length > 0) {
                        const imageData = CONFIG.IMAGES[Math.floor(Math.random() * CONFIG.IMAGES.length)];
                        content = imageData.name || imageData;
                        hue = imageData.hue || Math.random() * 360;
                        imagePath = imageData.path;
                        type = 'image';
                        console.log(`‚ûï Adding mixed image: ${content} from ${imagePath}`);
                    } else {
                        content = 'Hello';
                        hue = Math.random() * 360;
                        type = 'text';
                    }
                }

                const obj = createObject(content, type, hue, imagePath);

                // ƒê·ªëi t∆∞·ª£ng m·ªõi xu·∫•t hi·ªán ·ªü tr√™n c√πng
                obj.position.y = CONFIG.RESPAWN_Y + Math.random() * 20;

                scene.add(obj);
                objects.push(obj);
            }

            updateObjectCount();
            console.log(`‚ûï Th√™m ${addCount} ƒë·ªëi t∆∞·ª£ng m·ªõi`);
        }

        /**
         * X√≥a t·∫•t c·∫£ ƒë·ªëi t∆∞·ª£ng
         */
        function clearAllObjects() {
            objects.forEach(obj => {
                scene.remove(obj);
                obj.geometry.dispose();
                obj.material.dispose();
                if (obj.material.map) {
                    obj.material.map.dispose();
                }
            });

            objects = [];
            selectedObject = null;
            updateObjectCount();
            document.getElementById('selected-object').textContent = 'Kh√¥ng c√≥';
        }

        /**
         * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng ƒë·ªëi t∆∞·ª£ng hi·ªÉn th·ªã
         */
        function updateObjectCount() {
            // C·∫≠p nh·∫≠t trong UI info n·∫øu c√≥ element t∆∞∆°ng ·ª©ng
            const objectCountElement = document.querySelector('#info .value-display');
            if (objectCountElement) {
                objectCountElement.textContent = objects.length;
            }
        }

        /**
         * ·∫®n loading screen
         */
        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
            console.log('üéâ Loading completed, scene ready!');

            // Trigger auto-play sau khi loading ho√†n t·∫•t
            setTimeout(() => {
                triggerAutoPlay();
            }, 1000);
        }

        /**
         * Trigger auto-play (c√≥ th·ªÉ g·ªçi nhi·ªÅu l·∫ßn)
         */
        async function triggerAutoPlay() {
            console.log('üéµ triggerAutoPlay called');
            console.log('üéµ isMusicPlaying:', isMusicPlaying);
            console.log('üéµ userMadeChoice:', userMadeChoice);
            console.log('üéµ autoPlayAttempted:', autoPlayAttempted);

            if (isMusicPlaying || userMadeChoice) {
                console.log('üéµ Music already playing or user made choice, skipping auto-play');
                return;
            }

            console.log('üéµ Triggering auto-play...');

            if (currentMusicType === 'mp3' && mp3Player && mp3Player.audio) {
                await autoStartMusic();
            } else if (currentMusicType === 'ambient' && musicGenerator) {
                await autoStartAmbientMusic();
            } else {
                console.warn('‚ö†Ô∏è No music system available for auto-play');
            }
        }

        /**
         * Hi·ªÉn th·ªã l·ªói WebGL
         */
        function showWebGLError() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('webgl-error').style.display = 'block';
        }

        /**
         * V√≤ng l·∫∑p animation ch√≠nh
         */
        function animate() {
            requestAnimationFrame(animate);

            // C·∫≠p nh·∫≠t FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps-counter').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }

            // C·∫≠p nh·∫≠t hi·ªáu ·ª©ng l·∫•p l√°nh c·ªßa sao
            if (scene.userData.starsMaterial) {
                scene.userData.starsMaterial.uniforms.time.value = currentTime * 0.001;
            }

            // C·∫≠p nh·∫≠t ƒë·ªëi t∆∞·ª£ng
            updateObjects();

            // C·∫≠p nh·∫≠t controls
            controls.update();

            // Render scene
            renderer.render(scene, camera);
        }

        /**
         * C·∫≠p nh·∫≠t t·∫•t c·∫£ ƒë·ªëi t∆∞·ª£ng trong scene
         */
        function updateObjects() {
            const currentTime = Date.now();

            objects.forEach((obj, index) => {
                // X·ª≠ l√Ω hi·ªáu ·ª©ng spawn
                if (obj.userData.isSpawning) {
                    if (currentTime >= obj.userData.spawnTime) {
                        const spawnDuration = 500; // 500ms ƒë·ªÉ scale t·ª´ 0 l√™n 1
                        const elapsed = currentTime - obj.userData.spawnTime;
                        const progress = Math.min(elapsed / spawnDuration, 1);

                        // Easing function cho hi·ªáu ·ª©ng m∆∞·ª£t m√†
                        const easeOut = 1 - Math.pow(1 - progress, 3);
                        obj.scale.setScalar(easeOut);

                        if (progress >= 1) {
                            obj.userData.isSpawning = false;
                        }
                    }
                    return; // Kh√¥ng r∆°i khi ƒëang spawn
                }

                // Billboarding - lu√¥n h∆∞·ªõng v·ªÅ camera
                obj.lookAt(camera.position);

                // R∆°i xu·ªëng theo tr·ª•c Y th·∫ø gi·ªõi (kh√¥ng b·ªã ·∫£nh h∆∞·ªüng b·ªüi camera)
                if (!obj.userData.isPaused) {
                    // Ch·ªâ thay ƒë·ªïi Y, gi·ªØ nguy√™n X v√† Z
                    obj.position.y -= obj.userData.fallSpeed * fallSpeedMultiplier;

                    // Respawn khi r∆°i qu√° th·∫•p - t·∫°o l·∫°i v·ªã tr√≠ spherical
                    if (obj.position.y < CONFIG.DESPAWN_Y) {
                        // T·∫°o v·ªã tr√≠ m·ªõi tr√™n h√¨nh c·∫ßu v·ªõi kho·∫£ng c√°ch hi·ªán t·∫°i
                        const radius = objectSpacing * 0.8;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);

                        obj.position.x = radius * Math.sin(phi) * Math.cos(theta);
                        obj.position.y = CONFIG.RESPAWN_Y + Math.random() * 20;
                        obj.position.z = radius * Math.sin(phi) * Math.sin(theta);
                    }
                }

                // Hi·ªáu ·ª©ng glow nh·∫π
                if (obj.userData.isSelected) {
                    obj.material.emissiveIntensity = 0.6 + Math.sin(Date.now() * 0.005) * 0.2;
                } else {
                    obj.material.emissiveIntensity = 0.4;
                }
            });
        }


    </script>
</body>
</html>
